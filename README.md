## í”„ë¡œì íŠ¸ ê°œìš”

### í”„ë¡œì íŠ¸ ëª…: NeoSteel Rift

### ì¥ë¥´: VR ìŠˆíŒ… ë¡œê·¸ë¼ì´í¬ ê²Œì„
ë³¸ ê²Œì„ì€, ì‚¬ë°©ì—ì„œ ëª°ë ¤ì˜¤ëŠ” ëª¬ìŠ¤í„°ë¡œë¶€í„° ìƒì¡´í•˜ê³ , ì´ë¥¼ ì²˜ì¹˜í•˜ì—¬ ì„±ì¥í•˜ë©° ìµœì¢…ì ìœ¼ë¡œ ë“±ì¥í•˜ëŠ” ë³´ìŠ¤ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ë©´ í´ë¦¬ì–´í•˜ê²Œ ë˜ëŠ” VR ìŠˆíŒ… ë¡œê·¸ë¼ì´í¬ ì‹±ê¸€ í”Œë ˆì´ ê²Œì„ì…ë‹ˆë‹¤.<br/>
ì²¨ë¶€ëœ APK íŒŒì¼ì˜ ê²½ìš° í”Œë ˆì´ ì˜ìƒì—ì„œ ë³´ì´ëŠ” í”¼ê²© ì• ë‹ˆë©”ì´ì…˜ ë²„ê·¸ê°€ ìˆ˜ì •ëœ ë²„ì „ì´ë©°, Development Buildë¡œ ë˜ì–´ ìˆê³ , Meta Quest 3 Standalone VRìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.<br/>
ê°œë°œ ì¼ì§€ì˜ ê²½ìš° Notion, í”Œë ˆì´ ë° ê¸°ëŠ¥ ì„¤ëª…ì˜ ê²½ìš° Youtube ì˜ìƒì—ì„œ í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


<img src="./Images/Title_Image_1.png" width=100%>
<img src="./Images/Title_Image_2.png" width=100%>


### í”„ë¡œì íŠ¸ ì§„í–‰ íƒ€ì„ë¼ì¸

### Notion : [https://www.notion.so/NeoSteel-Rift-1ba37781ff7380e08b7cd05d1300bc0b](https://www.notion.so/NeoSteel-Rift-1ba37781ff7380e08b7cd05d1300bc0b?pvs=21)

### í”Œë ˆì´ ë° ê¸°ëŠ¥ ì„¤ëª… ì˜ìƒ

### Youtube : https://youtu.be/GQUvhovunlA

### í”„ë¡œì íŠ¸ ì§„í–‰ ê¸°ê°„

1. PC-VR ì—°ê²° ë²„ì „ : 2025.03.09 ~ 2025.06.12
2. Standalone VR ë²„ì „ : 2025.08.27 ~ 2025.09.17
<br/>

### ê°œë°œ ì¸ì› ë° ì—­í• 

ì‹ ìŠ¹ìš°
- ê²Œì„ ë””ìì¸ ë° ì‹œìŠ¤í…œ ì„¤ê³„
- í”„ë¡œì íŠ¸ ì—ì…‹ ì¡°ì‚¬ ë° ê´€ë¦¬
- í”„ë¡œì íŠ¸ ê´€ë¦¬ ë° PC-VR ì—°ë™ í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•
- FMOD ì„¤ì • ë° Audio System ì„¤ê³„ ë° êµ¬í˜„
- FSM ê¸°ë°˜ ì¼ë°˜ ëª¬ìŠ¤í„° AI êµ¬í˜„
- Behavior Tree ê¸°ë°˜ ë³´ìŠ¤ ëª¬ìŠ¤í„° AI êµ¬í˜„
- í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„° ê°„ì˜ ë¬¼ë¦¬ ìƒí˜¸ì‘ìš© ë° Hit System êµ¬í˜„
- ê²Œì„ í”Œë ˆì´ ì§„í–‰ ë§¤ë‹ˆì € ì‹œìŠ¤í…œ êµ¬í˜„
- ëª¬ìŠ¤í„° ì›¨ì´ë¸Œ êµ¬í˜„ ë° ê²Œì„ ë°¸ëŸ°ì‹±
- VFX, Particle System ìµœì í™”
- ì”¬ êµ¬ì„±, ë¼ì´íŒ… ì„¤ì • ë° ìµœì í™”
- í”Œë ˆì´ì–´ UI êµ¬í˜„ ë° ì •ì  ë¶ˆíˆ¬ëª… UI Sprite Atlas êµ¬ì„±
- Android ë¹Œë“œ ìµœì í™” ì„¤ì •
<br/>

í•œìœ ë¯¼
- VR Controller í™˜ê²½ êµ¬ì„± ë° í”Œë ˆì´ì–´ ì¡°ì‘ êµ¬í˜„
- ì´ê¸°(Pistol, Rifle) ë¡œì§ êµ¬í˜„
- ì´ê¸° ìŠ¤í‚¬ ì‹œìŠ¤í…œ êµ¬í˜„
- í”Œë ˆì´ì–´ ìŠ¤íƒ¯ ë° ë ˆë²¨ì—… ì‹œìŠ¤í…œ êµ¬í˜„
- í”Œë ˆì´ì–´ ìƒíƒœì— ë”°ë¥¸ HMD Effects êµ¬í˜„
- ì´ê¸° UI êµ¬í˜„
- ë³´ìŠ¤ ì¶œí˜„ ì‹œ ì—°ì¶œ êµ¬í˜„
- Android ë¹Œë“œ ìµœì í™” ì„¤ì •
- VR ê¸°ê¸° í™œìš© í…ŒìŠ¤íŠ¸ ë° í”Œë ˆì´ ì˜ìƒ ì´¬ì˜
<br/>

## ëª©ì°¨
1.[í”„ë¡œì íŠ¸ ì´ˆê¸° ê¸°íš ë° ë°°ê²½](#1-í”„ë¡œì íŠ¸-ì´ˆê¸°-ê¸°íš-ë°-ë°°ê²½)
<br/><br/>
2.[ê°œë°œ í™˜ê²½](#2-ê°œë°œ-í™˜ê²½)
<br/><br/>
3.[í”„ë¡œì íŠ¸ êµ¬ì¡°](#3-í”„ë¡œì íŠ¸-êµ¬ì¡°)
<br/><br/>
4.[ê¸°ëŠ¥ êµ¬í˜„ ë° ìµœì í™”](#4-ê¸°ëŠ¥-êµ¬í˜„-ë°-ìµœì í™”)
<br/><br/>
5.[ì‚¬ìš© ì—ì…‹](#5-ì‚¬ìš©-ì—ì…‹)
<br/><br/>
6.[ì°¸ê³  ìë£Œ](#6-ì°¸ê³ -ìë£Œ)
<br/><br/>
7.[í”„ë¡œì íŠ¸ ë¦¬ë·°](#7-í”„ë¡œì íŠ¸-ë¦¬ë·°)

<br/><br/>

## 1. í”„ë¡œì íŠ¸ ì´ˆê¸° ê¸°íš ë° ë°°ê²½
<img src="./Images/Background_1.png" width=100%>
<img src="./Images/Background_2.png" width=100%>

<br/>

### 1 - ì „íˆ¬ ì‹œìŠ¤í…œ: ì›ê±°ë¦¬ ìŠˆíŒ… ì¤‘ì‹¬ì˜ ì§ê´€ì  ì„¤ê³„

- VR í™˜ê²½ì—ì„œ ê·¼ì ‘ ì „íˆ¬ëŠ” ì •êµí•œ ë¬¼ë¦¬ í”¼ë“œë°± ì—†ì´ëŠ” í”Œë ˆì´ì–´ì—ê²Œ ë‹µë‹µí•¨ê³¼ ì¡°ì‘ì˜ ì–´ë ¤ì›€ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê·¼ì ‘ ìƒí˜¸ì‘ìš©ì˜ ë¹„ì¤‘ì„ ì¤„ì´ê³ , ì¡°ì¤€ê³¼ ë°œì‚¬ê°€ ì§ê´€ì ì¸ ì›ê±°ë¦¬ ìŠˆíŒ…ì„ í•µì‹¬ ì „íˆ¬ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ í”Œë ˆì´ì–´ëŠ” ë³µì¡í•œ ì¡°ì‘ ì—†ì´ë„ ì¦‰ê°ì ì¸ íƒ€ê²©ê°ê³¼ ì„±ì·¨ê°ì„ ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
<br/>

### 2 - **ì¥ë¥´ ì„ ì •:**Â VR ì‹œì¥ ë¶„ì„ì— ê¸°ë°˜í•œ 'ìŠˆíŒ… ë¡œê·¸ë¼ì´í¬' ì¥ë¥´ ë„ì „

- ì´ˆê¸° ê¸°íš ë‹¨ê³„ì—ì„œ í”„ë¡œì íŠ¸ì˜ ì¥ë¥´ë¥¼ â€˜VR ìŠˆíŒ… ë¡œê·¸ë¼ì´í¬â€™ë¡œ ê²°ì •í•œ ì´ìœ ëŠ” VR ê²Œì„ ì‹œì¥ì˜ íŠ¹ì„±ì„ ë¶„ì„í•œ ê²°ê³¼ì…ë‹ˆë‹¤. í˜„ì¬ VR ê²Œì„ ì‹œì¥ì˜ ëŒ€ë¶€ë¶„ì€ ì•¡ì…˜ ë° ìŠˆíŒ… ì¥ë¥´ê°€ ì°¨ì§€í•˜ê³  ìˆìŠµë‹ˆë‹¤. ë°˜ë©´, PC ê²Œì„ ì‹œì¥ì—ì„œëŠ” í° ì¸ê¸°ë¥¼ ëŒê³  ìˆëŠ” ë¡œê·¸ë¼ì´í¬ ì¥ë¥´ì˜ ê²Œì„ì€ VR í™˜ê²½ì—ì„œëŠ” ê±°ì˜ ì¶œì‹œë˜ì§€ ì•Šì€ ìƒí™©ì´ì—ˆìŠµë‹ˆë‹¤.
- ì´ëŸ¬í•œ ì‹œì¥ì˜ ë¶ˆê· í˜• ì†ì—ì„œ ê¸°íšŒë¥¼ ë°œê²¬í•˜ê³ , VR ì‹œì¥ì— ë¶€ì¡±í–ˆë˜ ë¡œê·¸ë¼ì´í¬ ì¥ë¥´ì— ë„ì „í•˜ê¸°ë¡œ ê²°ì •í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” VR ê²Œì„ì˜ ê°•ì ì¸ ë†’ì€ ëª°ì…ê°ì˜ ìŠˆíŒ… í”Œë ˆì´ì™€ PCì—ì„œ ê²€ì¦ëœ ë¡œê·¸ë¼ì´í¬ì˜ ë°˜ë³µì ì¸ ì¬ë¯¸ë¥¼ ê²°í•©í•˜ì—¬ ìƒˆë¡œìš´ ê²Œì„ ê²½í—˜ì„ ì œê³µí•˜ë ¤ëŠ” ì‹œë„ì…ë‹ˆë‹¤.
<br/>

### 3 - **ë°°ê²½ ì½˜ì…‰íŠ¸:**Â VR ê¸°ìˆ  ì´ë¯¸ì§€ì™€ ë¶€í•©í•˜ëŠ” ë¯¸ë˜ì§€í–¥ì  SF ì„¸ê³„ê´€ êµ¬ì¶•

- ê²Œì„ì˜ ë°°ê²½ì„ ë¯¸ë˜ì§€í–¥ì ì¸ SFë¡œ ì„¤ì •í•œ ì´ìœ ëŠ” VR ì´ë¼ëŠ” ê¸°ìˆ ì´ ê°€ì§„ ì²¨ë‹¨ ì´ë¯¸ì§€ì™€ SF ì¥ë¥´ì˜ ë¯¸ë˜ì  ì½˜ì…‰íŠ¸ê°€ ì˜ ì–´ìš¸ë¦°ë‹¤ê³  íŒë‹¨í–ˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
- ì´ë¥¼ í†µí•´ ê²Œì„ì˜ ì‹œê°ì ì¸ ìš”ì†Œë¥¼ ê°•í™”í•˜ê³ , í”Œë ˆì´ì–´ì—ê²Œ ë”ìš± ìƒˆë¡­ê³  ëª°ì…ê° ë†’ì€ ê²½í—˜ì„ ì œê³µí•˜ê³ ì í–ˆìŠµë‹ˆë‹¤. ìµœì¢…ì ìœ¼ë¡œ VR ê¸°ìˆ ì˜ ê°•ì ì¸ ëª°ì…ê° ë†’ì€ ìŠˆíŒ… í”Œë ˆì´ì™€ PCì—ì„œ ê²€ì¦ëœ ë¡œê·¸ë¼ì´í¬ì˜ ë°˜ë³µì ì¸ ì¬ë¯¸, ê·¸ë¦¬ê³  SF ë°°ê²½ì˜ ì‹œê°ì  ë§¤ë ¥ì„ ê²°í•©í•˜ì—¬ ìƒˆë¡œìš´ ê²Œì„ ê²½í—˜ì„ ì°½ì¡°í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ ì‚¼ì•˜ìŠµë‹ˆë‹¤.
<br/>

### 4 - **ë§µ ë””ìì¸:**Â VR ìµœì í™”ë¥¼ ê³ ë ¤í•œ ì‹¤ë‚´ ê³µê°„ ë° ì •ì  ì¡°ëª… í™œìš©

- ê²Œì„ì˜ ì£¼ ë¬´ëŒ€ë¥¼ ë„“ì€ ì°½ê³ ë¡œ ì„¤ì •í•œ ê²ƒì€ ì½˜ì…‰íŠ¸ì˜ ì§‘ì¤‘ê³¼ VR í™˜ê²½ ìµœì í™”ë¼ëŠ” ë‘ ê°€ì§€ í•µì‹¬ì ì¸ ì´ìœ  ë•Œë¬¸ì…ë‹ˆë‹¤.
- í”„ë¡œì íŠ¸ ì´ˆê¸°, ë°°ê²½ì„ êµ¬ìƒí•˜ë©° ê°œë°©ëœ ì™¸ë¶€ì™€ í•œì •ëœ ë‚´ë¶€ ê³µê°„ ì‚¬ì´ì—ì„œ ê³ ë¯¼í–ˆìŠµë‹ˆë‹¤. ë¯¸ë˜ì§€í–¥ì  ì½˜ì…‰íŠ¸ë¥¼ í‘œí˜„í•˜ê¸°ì— ì™¸ë¶€ í™˜ê²½ì€ ë””ìì¸ì ìœ¼ë¡œ êµ¬í˜„í•  ìš”ì†Œê°€ ë§ì§€ë§Œ, ì´ëŠ” ë°©ëŒ€í•œ ê·¸ë˜í”½ ìì›ì„ ìš”êµ¬í•˜ì—¬ VR í™˜ê²½ì—ì„œëŠ” ìµœì í™” ë¬¸ì œë¥¼ ì•¼ê¸°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ì´ëŸ¬í•œ ê¸°ìˆ ì  í•œê³„ë¥¼ ê³ ë ¤í•˜ì—¬, 'í”Œë ˆì´ì–´ê°€ ë‚´ë¶€ ê³µê°„ì¸ ì°½ê³ ì— ê°‡í˜€ í¬íƒˆì„ í†µí•´ ëŠì„ì—†ì´ ìƒì„±ë˜ëŠ” ë¡œë´‡ ëª¬ìŠ¤í„°ë“¤ì„ ì²˜ì¹˜í•œë‹¤'ëŠ” êµ¬ì²´ì ì¸ ì½˜ì…‰íŠ¸ë¥¼ ì„¤ì •í–ˆìŠµë‹ˆë‹¤. ì´ ì„¤ì •ì€ í•œì •ëœ ê³µê°„ì„ í™œìš©í•˜ì—¬ ê²Œì„ì˜ ëª©í‘œë¥¼ ëª…í™•íˆ í•˜ê³ , í”Œë ˆì´ì–´ì˜ ëª°ì…ë„ë¥¼ ë†’ì´ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.
<br/>

### 5 - ìŠ¤í‚¬ ë° **ë¬´ê¸° ì‹œìŠ¤í…œ:**Â ë‹¨ê³„ì  êµ¬ì„±ì„ í†µí•œ ì„±ì¥ ëª©í‘œ ë° ì„±ì·¨ê° ì œê³µ

- ê¶Œì´(Pistol)ê³¼ ì†Œì´(Rifle)ìœ¼ë¡œ ë¬´ê¸°ë¥¼ êµ¬ë¶„í•˜ì—¬ ê¸°íší•œ ê²ƒì€ ë¡œê·¸ë¼ì´í¬ ì¥ë¥´ì˜ í•µì‹¬ì¸ ì ì§„ì ì¸ ì„±ì¥ê³¼ ë„ì „ì˜ ì¬ë¯¸ë¥¼ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. ê²Œì„ ì´ˆë°˜ì— í”Œë ˆì´ì–´ëŠ” ê¶Œì´ìœ¼ë¡œ ì‹œì‘í•˜ë©°, ëª¬ìŠ¤í„°ë¥¼ ì²˜ì¹˜í•˜ë©° ì–»ëŠ” ë³´ìƒì„ í†µí•´ ê³µê²©ë ¥ì„ ì ì°¨ ê°•í™”í•´ ë‚˜ê°‘ë‹ˆë‹¤.
- í•˜ì§€ë§Œ ê²Œì„ì´ ì§„í–‰ë˜ì–´ ëª¬ìŠ¤í„°ì˜ ìˆ˜ê°€ ëŠ˜ì–´ë‚˜ê³  ë‹¤ì–‘í•œ íŒ¨í„´ì˜ ì ë“¤ì´ ë“±ì¥í•˜ë©´, ê°•í™” ë° ìŠ¤í‚¬ì„ ë³´ìœ í•œ ê¶Œì´ë§Œìœ¼ë¡œëŠ” í•œê³„ì— ë¶€ë”ªíˆëŠ” ì‹œì ì´ ì˜¤ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤. ë°”ë¡œ ì´ ì‹œì ì— â€˜ì†Œì´â€™ íšë“ì´ë¼ëŠ” ëª…í™•í•œ ëª©í‘œë¥¼ ì œì‹œí•¨ìœ¼ë¡œì¨, í”Œë ˆì´ì–´ëŠ” ìƒˆë¡œìš´ ê²½í—˜ì„ ë§ì´í•˜ê²Œ ë©ë‹ˆë‹¤.
- ì´ì²˜ëŸ¼ ë¬´ê¸° ì‹œìŠ¤í…œì— ëšœë ·í•œ ë‹¨ê³„ë¥¼ ë‘” ê²ƒì€ í”Œë ˆì´ì–´ê°€ ê²Œì„ì— ì‰½ê²Œ ì§€ë£¨í•¨ì„ ëŠë¼ì§€ ì•Šê³ , ì§€ì†ì ì¸ ëª°ì…ê°ì„ ìœ ì§€í•˜ë©° ì„±ì¥ê³¼ ê·¹ë³µì˜ ì¬ë¯¸ë¥¼ ê²½í—˜í•˜ê²Œ í•˜ê¸° ìœ„í•œ í•µì‹¬ì ì¸ ê¸°íš ì˜ë„ì…ë‹ˆë‹¤.
<br/>

### 6 - ì´ë™ ì‹œìŠ¤í…œ: ë©€ë¯¸(Motion Sickness - Sensory Conflict) ìµœì†Œí™”

VR ê²½í—˜ì˜ ê°€ì¥ í° ì¥ë²½ì¸ ë©€ë¯¸ë¥¼ í•´ê²°í•˜ëŠ” ê²ƒì„ ìµœìš°ì„  ê³¼ì œë¡œ ì‚¼ì•˜ìŠµë‹ˆë‹¤.

- **ì´ë™ ë°©ì‹**: ë±€ì„œë¼ì´í¬ ì¥ë¥´ì˜ íŠ¹ì„±ìƒ ëŠì„ì—†ëŠ” ì´ë™ì´ í•„ìˆ˜ì ì´ë¯€ë¡œ, ì¼ë°˜ì ì¸ í…”ë ˆí¬íŠ¸ ë°©ì‹ì€ ê²Œì„ì˜ íë¦„ì„ í•´ì¹œë‹¤ê³  íŒë‹¨í•˜ì—¬ ì œì™¸í–ˆìŠµë‹ˆë‹¤. ëŒ€ì‹ , í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„°ì˜ ì „ì²´ì ì¸ ì´ë™ ì†ë„ë¥¼ ë‚®ì¶° ì‹œê° ì •ë³´ì™€ ì „ì • ê°ê°ì˜ ë¶ˆì¼ì¹˜ë¥¼ ì¤„ì˜€ìŠµë‹ˆë‹¤.
- **íšŒì „ ë°©ì‹:** ë¶€ë“œëŸ¬ìš´ íšŒì „(Smooth Turn) ì‹œ ë°œìƒí•˜ëŠ” ì§€ì†ì ì¸ í™”ë©´ ë³€í™”ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´, ì‹œì ì„ ìˆœê°„ì ìœ¼ë¡œ 45ë„ì”© ì „í™˜í•˜ëŠ” **Snap Turn ë°©ì‹ì„ ë„ì…**í•˜ì—¬ íšŒì „ìœ¼ë¡œ ì¸í•œ ë©€ë¯¸ë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ì–µì œí–ˆìŠµë‹ˆë‹¤.
- **Vergence Accommodation Mismatch Problem:** í”Œë ˆì´ì–´ê°€ í”¼í•´ë¥¼ ë°›ì§€ ì•Šë„ë¡ ê´€ì¸¡í•˜ë©° ì¡°ì‘ì„ í†µí•´ í”¼í•´ì•¼ í•˜ëŠ” ëª¬ìŠ¤í„°ì˜ íˆ¬ì‚¬ì²´ì˜ ê²½ìš° ì†ë„ë¥¼ ë‚®ì¶”ì—ˆìŠµë‹ˆë‹¤.
- **Convergence Insufficiency Problem:** ê·¼ê±°ë¦¬ì— ìµœëŒ€í•œ ì´ˆì ì„ ë§ì¶”ì§€ ì•Šì•„ë„ ë˜ë„ë¡ ìµœì†Œí•œì˜ ê·¼ê±°ë¦¬ ì‹œì•¼ë¥¼ ë³´ì¥í•˜ë„ë¡ ì„¤ê³„í•˜ì˜€ìŠµë‹ˆë‹¤.
<br/>

### 7 - ë ˆë²¨ ë””ìì¸: ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìœ„í˜‘ìœ¼ë¡œ ì¸ì§€ ë¶€í•˜ ê°ì†Œ

- ì‚¬ë°©ì—ì„œ ì ì´ ë“±ì¥í•˜ëŠ” ì¥ë¥´ì  íŠ¹ì„±ì´ VR í™˜ê²½ì—ì„œëŠ” ê³¼ë„í•œ ìŠ¤íŠ¸ë ˆìŠ¤ì™€ ë©€ë¯¸ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ëª¬ìŠ¤í„°ê°€ ìŠ¤í°ë  ìœ„ì¹˜ì— í¬íƒˆ ì´í™íŠ¸ì™€ ê°™ì€ ì‹œê°ì  ì˜ˆê³ ë¥¼ ë¨¼ì € í‘œì‹œí•˜ì—¬, í”Œë ˆì´ì–´ê°€ ìœ„í˜‘ì˜ ë°©í–¥ì„ ì˜ˆì¸¡í•˜ê³  ëŒ€ë¹„í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” ê°‘ì‘ìŠ¤ëŸ¬ìš´ ìƒí™© ë³€í™”ë¡œ ì¸í•œ ì¸ì§€ ë¶€í•˜ë¥¼ ì¤„ì—¬ ë”ìš± ì¾Œì í•œ í”Œë ˆì´ ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.
<br/><br/>

## 2. ê°œë°œ í™˜ê²½

### Unity

- Unity 2022.3.60f1
- Unity XR Interaction Toolkit 3.0.3
- Oculus Integration SDK

### FMOD

- FMOD 2.03.07

### XR

- Meta Quest 3

<br/><br/>
## 3. í”„ë¡œì íŠ¸ êµ¬ì¡°

```
ğŸ“¦Scripts_Sample
 â”£ ğŸ“‚AudioController									#ì˜¤ë””ì˜¤ ê´€ë¦¬
 â”ƒ â”£ ğŸ“œBGMController.cs
 â”ƒ â”£ ğŸ“œPlayerPistolAudioController.cs
 â”ƒ â”£ ğŸ“œPlayerRifleAudioController.cs
 â”ƒ â”— ğŸ“œUIAudioController.cs
 â”£ ğŸ“‚BossMonster										#ë³´ìŠ¤ ëª¬ìŠ¤í„°(Behavior Tree)
 â”ƒ â”£ ğŸ“‚Area Attack
 â”ƒ â”ƒ â”£ ğŸ“œAreaAttack.cs
 â”ƒ â”ƒ â”£ ğŸ“œAreaAttackAudioController.cs
 â”ƒ â”ƒ â”£ ğŸ“œRepeatSpawnAreaAttackNode.cs
 â”ƒ â”ƒ â”— ğŸ“œVRAreaAttack.cs
 â”ƒ â”£ ğŸ“‚Base												#ë³´ìŠ¤ ëª¬ìŠ¤í„°(Composite Nodes, Blackboard, Controller, ...)
 â”ƒ â”ƒ â”£ ğŸ“œBossAnimatorController.cs
 â”ƒ â”ƒ â”£ ğŸ“œBossAudioController.cs
 â”ƒ â”ƒ â”£ ğŸ“œBossBTController.cs
 â”ƒ â”ƒ â”£ ğŸ“œBTBlackboard.cs
 â”ƒ â”ƒ â”£ ğŸ“œBTNode.cs
 â”ƒ â”ƒ â”£ ğŸ“œDeathHandler.cs
 â”ƒ â”ƒ â”£ ğŸ“œParallelNode.cs
 â”ƒ â”ƒ â”£ ğŸ“œRepeatShootNode.cs
 â”ƒ â”ƒ â”£ ğŸ“œSelectorNode.cs
 â”ƒ â”ƒ â”— ğŸ“œSequenceNode.cs
 â”ƒ â”£ ğŸ“‚BossBulletSpawner								#ë³´ìŠ¤ ëª¬ìŠ¤í„° ê¸°ë³¸ ê³µê²©
 â”ƒ â”ƒ â”£ ğŸ“œBossBulletSpawnerController.cs
 â”ƒ â”ƒ â”£ ğŸ“œCheckWeaponAliveNode.cs
 â”ƒ â”ƒ â”£ ğŸ“œSpawnRotator.cs
 â”ƒ â”ƒ â”— ğŸ“œWeaponHitBox.cs
 â”ƒ â”£ ğŸ“‚BulletAttack										#ë³´ìŠ¤ ëª¬ìŠ¤í„° íˆ¬ì‚¬ì²´
 â”ƒ â”ƒ â”— ğŸ“œBossBullet.cs
 â”ƒ â”£ ğŸ“œBossHitBox.cs
 â”ƒ â”£ ğŸ“œBossHitHandler.cs
 â”ƒ â”£ ğŸ“œCheckIfDeadNode.cs
 â”ƒ â”£ ğŸ“œCheckPlayerDistanceNode.cs
 â”ƒ â”£ ğŸ“œComparisonMode.cs
 â”ƒ â”£ ğŸ“œDefaultAttackNode.cs
 â”ƒ â”£ ğŸ“œLookAroundNode.cs
 â”ƒ â”£ ğŸ“œMoveToTargetNode.cs
 â”ƒ â”£ ğŸ“œPatrolNode.cs
 â”ƒ â”£ ğŸ“œReactiveSequenceNode.cs
 â”ƒ â”— ğŸ“œRotateTowardsTargetNode.cs
 â”£ ğŸ“‚HitSystem											#ëª¬ìŠ¤í„° í”¼ê²© ì‹œìŠ¤í…œ
 â”ƒ â”£ ğŸ“‚Data
 â”ƒ â”ƒ â”— ğŸ“œHitData.cs
 â”ƒ â”£ ğŸ“‚Interfaces
 â”ƒ â”ƒ â”— ğŸ“œIHitProcessor.cs
 â”ƒ â”— ğŸ“‚Processors
 â”ƒ â”ƒ â”— ğŸ“œMonsterHitProcessor.cs
 â”£ ğŸ“‚Logger
 â”ƒ â”£ ğŸ“œCustomLogger.cs
 â”ƒ â”— ğŸ“œLogExample.cs
 â”£ ğŸ“‚Managers											#GameManager, SubManagers
 â”ƒ â”£ ğŸ“œDataManager.cs
 â”ƒ â”£ ğŸ“œGameManager.cs
 â”ƒ â”£ ğŸ“œPoolManager.cs
 â”ƒ â”£ ğŸ“œSingleton.cs
 â”ƒ â”£ ğŸ“œSoundManager.cs
 â”ƒ â”— ğŸ“œWaveManager.cs
 â”£ ğŸ“‚Monster											#ì¼ë°˜ ëª¬ìŠ¤í„°(FSM, VFX, Animation, HitBox, ...)
 â”ƒ â”£ ğŸ“‚Refactoring										#ë¦¬íŒ©í† ë§ í›„
 â”ƒ â”ƒ â”£ ğŸ“‚Attack											#ì¼ë°˜ ëª¬ìŠ¤í„° ê³µê²©
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚Rob01Attack
 â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“œRob01AttackHandler.cs
 â”ƒ â”ƒ â”ƒ â”ƒ â”— ğŸ“œRob01AttackSO.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“‚Rob03Attack
 â”ƒ â”ƒ â”ƒ â”ƒ â”£ ğŸ“œRob03AttackHandler.cs
 â”ƒ â”ƒ â”ƒ â”ƒ â”— ğŸ“œRob03AttackSO.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œAttackRaycastPoints.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œAttackSO.cs
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œMonsterAttack.cs
 â”ƒ â”ƒ â”£ ğŸ“‚Core											#ì¼ë°˜ ëª¬ìŠ¤í„°(Controller)
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œIDamageable.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œMonsterControllerRefactored.cs
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œMonsterRotationController.cs
 â”ƒ â”ƒ â”— ğŸ“‚States											#ì¼ë°˜ ëª¬ìŠ¤í„°(States)
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œAttackState.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œChaseState.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œDeadState.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œHitState.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œIdleState.cs
 â”ƒ â”ƒ â”ƒ â”£ ğŸ“œMonsterStateBase.cs
 â”ƒ â”ƒ â”ƒ â”— ğŸ“œSpawnState.cs
 â”ƒ â”£ ğŸ“œHitBox.cs
 â”ƒ â”£ ğŸ“œMonsterAudioController.cs
 â”ƒ â”£ ğŸ“œMonsterBullet.cs
 â”ƒ â”£ ğŸ“œMonsterController.cs								#ë¦¬íŒ©í† ë§ ì „
 â”ƒ â”£ ğŸ“œMonsterHitSplash.cs
 â”ƒ â”£ ğŸ“œRendererController.cs
 â”ƒ â”£ ğŸ“œRobotAnimator.cs
 â”ƒ â”— ğŸ“œSpawner.cs
 â”£ ğŸ“‚Player												#í”Œë ˆì´ì–´ ì¡°ì‘
 â”ƒ â”£ ğŸ“‚XRSetting
 â”ƒ â”ƒ â”— ğŸ“œPlayerColliderController.cs
 â”ƒ â”£ ğŸ“œNavTargetMover.cs
 â”ƒ â”£ ğŸ“œPistolBulletAudioController.cs
 â”ƒ â”£ ğŸ“œPlayerAudioController.cs
 â”ƒ â”— ğŸ“œPlayerBullet.cs
 â”£ ğŸ“‚ScriptableObjects									#ScriptableObjects ìƒì„±
 â”ƒ â”£ ğŸ“œMonsterDataSO.cs
 â”ƒ â”£ ğŸ“œPlayerDataSO.cs
 â”ƒ â”£ ğŸ“œPoolDataSO.cs
 â”ƒ â”— ğŸ“œSpawnerWaveSO.cs
 â”£ ğŸ“‚Utility											#ê²Œì„ ê°œë°œ ë° í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì„±ìš©
 â”ƒ â”£ ğŸ“œCombineMeshes.cs
 â”ƒ â”£ ğŸ“œIPoolable.cs
 â”ƒ â”£ ğŸ“œShaderPrewarmer.cs
 â”ƒ â”— ğŸ“œTimer.cs
 â”— ğŸ“‚VFX												#ì´í™íŠ¸ Pooling
 â”ƒ â”£ ğŸ“œParticleAutoReturn.cs
 â”ƒ â”— ğŸ“œVFXAutoReturn.cs
```

<br/><br/>

## 4. ê¸°ëŠ¥ êµ¬í˜„ ë° ìµœì í™”

#### ì•„ë˜ì˜ ì½”ë“œë“¤ì€ ê¸°ì¡´ ì½”ë“œì—ì„œ ì£¼ìš” ë¶€ë¶„ë§Œ ë°œì·Œ ë° ì„¤ëª…ì„ ì¶”ê°€í•œ ê²ƒìœ¼ë¡œ ì „ì²´ ë¶€ë¬¸ì€ í”„ë¡œì íŠ¸ êµ¬ì¡° í•­ëª©ì„ ë”°ë¼ ì ‘ê·¼ í›„, í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë³¸ í•­ëª©ì—ì„œëŠ” í•µì‹¬ ê¸°ëŠ¥ë“¤ ì¤‘ ì¼ë¶€ì˜ ì´ˆê¸° ì„¤ê³„, ê°œë°œ ê³¼ì •, ë³€ê²½ ê³¼ì •, ì‹œìŠ¤í…œ êµ¬ì¡°ë¥¼ ìœ„ì£¼ë¡œ ê¸°ìˆ í•˜ì˜€ìŠµë‹ˆë‹¤.

<br/>

###í”„ë ˆì„ ë¹„êµ: Standalone VR ê¸°ì¤€ í”„ë ˆì„ ì¸¡ì •
    
ìµœì í™” ì „

í‰ê·  26.5 í”„ë ˆì„

ìµœì € 17 í”„ë ˆì„

ìµœê³  36 í”„ë ˆì„
<img src="./Images/Before_Frame.png" width=100%>

<br/>
ìµœì í™” í›„

í‰ê·  78 í”„ë ˆì„

ìµœì € 54 í”„ë ˆì„

ìµœê³  84 í”„ë ˆì„

<img src="./Images/After_Frame.png" width=100%>
    
<br/>


### 1. AI ì‹œìŠ¤í…œ: FSMê³¼ Behavior Treeì˜ ëª©ì  ê¸°ë°˜ ì„¤ê³„

ì´ í”„ë¡œì íŠ¸ì˜ í•µì‹¬ ì½˜í…ì¸  ì¤‘ í•˜ë‚˜ëŠ” ëŠì„ì—†ì´ ë“±ì¥í•˜ëŠ” ëª¬ìŠ¤í„°ì™€ì˜ ì „íˆ¬ì…ë‹ˆë‹¤. ë”°ë¼ì„œ í”Œë ˆì´ì–´ ì…ì¥ì—ì„œ ë¹„í•©ë¦¬ì ì´ë¼ê³  ëŠë¼ì§€ ì•Šê³  ê³µëµì´ ê°€ëŠ¥í•˜ë©° ìì—°ìŠ¤ëŸ¬ìš´ ì›€ì§ì„ì„ ê°€ì§„ AIë¥¼ ì„¤ê³„í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•œ ê³¼ì œì˜€ìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ì´ˆê¸°ì—ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ê³„í•˜ì˜€ì§€ë§Œ, íšŒì „ì´ë‚˜ ì¥ì• ë¬¼ íŒë‹¨ê³¼ ê°™ì€ ì‹¤ì‹œê°„ìœ¼ë¡œ ì •í™•í•œ í–‰ë™ì— ì í•©í•˜ì§€ ì•Šì•„ ì´ë¥¼ ë§ì¶°ê°€ë©° ì§„í–‰í•˜ì˜€ìŠµë‹ˆë‹¤.

#### A - ì¼ë°˜ ëª¬ìŠ¤í„° AI: FSM

- ë‹¤ìˆ˜ë¡œ ë“±ì¥í•˜ëŠ” ì¼ë°˜ ëª¬ìŠ¤í„°ëŠ” â€˜ìƒì„±â€™, â€˜ëŒ€ê¸°â€™, â€˜ì¶”ê²©â€™, â€˜ê³µê²©â€™ ë“±ê³¼ ê°™ì´ ëª…í™•í•˜ê³  ì„ í˜•ì ì¸ ìƒíƒœ ë³€í™”ë¥¼ ê°€ì§‘ë‹ˆë‹¤. ì´ëŸ¬í•œ AIëŠ” ìœ í•œ ìƒíƒœ ë¨¸ì‹ (Finite State Machine, FSM)ìœ¼ë¡œ êµ¬í˜„í•  ë•Œ, ê° ìƒíƒœì˜ ì±…ì„ì´ ëª…í™•í•´ì§€ê³  íš¨ìœ¨ì„±ìˆê²Œ ì£¼ì–´ì§„ ìƒíƒœë¥¼ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•  ê²ƒì´ë¼ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤.

##### A - 1. ì´ˆê¸° ê°œë°œ

- Monster AIì˜ FSMì„ ì²˜ìŒ êµ¬í˜„í•´ë³´ëŠ” ë‹¨ê³„ì—ì„œ ê° ìƒíƒœë³„ë¡œ í´ë˜ìŠ¤ë¥¼ ë‚˜ëˆ„ê³  ìƒì†í•˜ë©° ì²˜ë¦¬í•˜ê¸°ì—ëŠ” ì´í•´ë„ê°€ ë¶€ì¡±í•˜ì˜€ê³ , ê²Œì„ ë‚´ ì—ì…‹ì´ ëª¨ë‘ ë‹¤ë¥¸ ì œì‘ì‚¬ì´ê¸°ì— í†µì¼ì„±ì„ ê°€ì§ˆ ìˆ˜ ìˆëŠ”ì§€ ê²€ì¦ì„ í•˜ê¸° ìœ„í•´ ë¹ ë¥´ê²Œ ê°œë°œí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°í•˜ì—¬, MosterController.csì™€ ê°™ì´ ëª¨ë“  íë¦„ì„ í•˜ë‚˜ì˜ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ê´€ë¦¬í•˜ì˜€ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ, ì²« ë‹¨ê³„ì˜ ê°œë°œì´ ëë‚˜ê³  ë‘ ë²ˆì§¸ ëª¬ìŠ¤í„°ë¥¼ ì¶”ê°€ì ìœ¼ë¡œ ê°œë°œí•˜ê³ ì í•˜ì˜€ì„ ë•Œ, ëª¬ìŠ¤í„°ì˜ ê³µê²©, ê·¸ë¦¬ê³  ëª¬ìŠ¤í„°ì˜ í”¼ê²© ë“±ì— ë‹¤ì–‘ì„±ì„ ì£¼ê¸°ì—ëŠ” í´ë˜ìŠ¤ë¥¼ ë¶„ë¦¬í•´ì•¼ í•˜ì˜€ê³ , ê° ìƒíƒœë³„ë¡œ Enter ë° Exit ë‹¨ê³„ë¥¼ ëª¨ë‘ Flagë¡œ ì²˜ë¦¬í•˜ì—¬ì„œ ë¡œì§ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ì–´ë ¤ìš´ ì ì´ ìˆì—ˆìŠµë‹ˆë‹¤.
- ì´ë¡œ ì¸í•´, MonsterControllerRefactored.csì™€ ê°™ì´ ì´ˆê¸°í™” ë° ê³µí†µ í•µì‹¬ ë¡œì§ë§Œ ë‚¨ê²¨ë‘ê³  ë‚˜ë¨¸ì§€ ìŠ¤í¬ë¦½íŠ¸ëŠ” ë¶„ë¦¬ì‹œí‚¤ëŠ” ë°©ì•ˆì„ ê³ ì•ˆí•˜ì—¬ ì§€ê¸ˆì˜ íŒŒì¼ êµ¬ì¡°ì™€ ê°™ì´ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤. ë ˆí¬ì§€í† ë¦¬ ë‚´ì—ëŠ”  ë³€ê²½ëœ ì ì„ í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆê²Œ ì˜ë„ì ìœ¼ë¡œ í´ë˜ìŠ¤ ëª…ì„ ì´ì™€ ê°™ì´ ë‘ê³  ë‘ ìŠ¤í¬ë¦½íŠ¸ ëª¨ë‘ ë‚¨ê²¨ë‘ì—ˆìŠµë‹ˆë‹¤.

- ê¸°ì¡´ì˜ MonsterController.cs : God Classì˜ ë¬¸ì œì 

```csharp
// In (Old) Scripts/SSW/Monster/MonsterController.cs
public class MonsterController : MonoBehaviour
{
		private MonsterState _state = MonsterState.Spawn;
		// ëª¨ë“  ë¡œì§ê³¼ ìƒíƒœ ë³€ìˆ˜ë“¤ì´ í•œ í´ë˜ìŠ¤ì— ì¡´ì¬
		private void Update()
		{
		    switch (_state)
		    {
		        case MonsterState.Spawn:
		            UpdateSpawnState();
		            break;
		        case MonsterState.Idle:
		            UpdateIdleState();
		            break;
		        case MonsterState.Chase:
		            UpdateChaseState();
		            break;
		        // ...
		    }
		}
		
		// ê° ìƒíƒœì— ëŒ€í•œ ëª¨ë“  ë¡œì§ ë©”ì„œë“œê°€ í•œ í´ë˜ìŠ¤ ë‚´ì— ì¡´ì¬
		private void UpdateIdleState() { /*...*/ }
		private void UpdateChaseState() { /*...*/ }
		IEnumerator CoAttackSequence() { /*...*/ }
		IEnumerator CoKnockback() { /*...*/ }
}
```

##### A - 2. ì•„í‚¤í…ì²˜ì˜ 3ê°œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

- MonsterControllerRefactored.cs
  ëª¬ìŠ¤í„°ì˜ ë‡Œ ì—­í• ì„ í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

  ëª¨ë“  ìƒíƒœ ê°ì²´ë¥¼ Dictionaryë¡œ ìƒì„±í•˜ì—¬ ì†Œìœ í•˜ê³ , í˜„ì¬ ì–´ë–¤ ìƒíƒœì¸ì§€ë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

  ëª¬ìŠ¤í„°ë¥¼ ìœ ì§€í•˜ëŠ”ë° í•„ìš”í•œ ëª¬ìŠ¤í„°ì˜ ë¬¼ë¦¬, ì• ë‹ˆë©”ì´ì…˜, ë°ì´í„°, ìƒëª… ì£¼ê¸° ë“± í•µì‹¬ ë¦¬ì†ŒìŠ¤ì˜ ì ‘ê·¼ê³¼ ê´€ë¦¬ë¥¼ ëª¨ë‘ ì±…ì„ì§‘ë‹ˆë‹¤.

  ë˜í•œ, ì™¸ë¶€ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì—­í• ë„ ìˆ˜í–‰í•˜ë„ë¡ ì„¤ê³„í•˜ì˜€ìŠµë‹ˆë‹¤.

â‡’ ìƒíƒœ ë³€í™”

```csharp
// In Scripts/SSW/Monster/Refactoring/Core/MonsterControllerRefactored.cs
public class MonsterControllerRefactored : MonoBehaviour, IDamageable
{
		// ...
		private MonsterStateBase _currentState; // í˜„ì¬ í™œì„±í™”ëœ ìƒíƒœ ê°ì²´
		private Dictionary<MonsterState, MonsterStateBase> _states; // ëª¨ë“  ìƒíƒœ ê°ì²´ ì €ì¥ì†Œ
		private void InitializeStates()
		{
		    _states = new Dictionary<MonsterState, MonsterStateBase>
		    {
		        { MonsterState.Spawn, new SpawnState(this) },
		        { MonsterState.Idle, new IdleState(this) },
		        { MonsterState.Chase, new ChaseState(this) },
		        // ... ë‹¤ë¥¸ ìƒíƒœë“¤ë„ ë™ì¼í•˜ê²Œ ì´ˆê¸°í™”
		    };
		}
		
		public void ChangeState(MonsterState newState)
		{
		    _currentState?.OnExit(); // ì•ˆì „í•˜ê²Œ í˜„ì¬ ìƒíƒœì˜ Exit ë¡œì§ í˜¸ì¶œ
		
		    if (_states.TryGetValue(newState, out MonsterStateBase nextState))
		    {
		        _currentState = nextState; // ìƒˆë¡œìš´ ìƒíƒœë¡œ êµì²´
		        _currentStateEnum = newState;
		        _currentState.OnEnter(); // ìƒˆë¡œìš´ ìƒíƒœì˜ Enter ë¡œì§ í˜¸ì¶œ
		    }
		}
		
		private void Update()
		{
		    // ...
		    _currentState?.OnUpdate(); // ë§¤ í”„ë ˆì„ í˜„ì¬ ìƒíƒœì˜ Update ë¡œì§ë§Œ í˜¸ì¶œ
		}
}

```
<br/>
â‡’ ìƒëª… ì£¼ê¸° ê´€ë¦¬ ë° ë¦¬ì†ŒìŠ¤ ì ‘ê·¼

```csharp
// In Scripts/SSW/Monster/Refactoring/Core/MonsterControllerRefactored.cs
// ëª¬ìŠ¤í„°ì˜ ëª¨ë“  í•µì‹¬ ë¶€í’ˆ(ì»´í¬ë„ŒíŠ¸)ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ì†Œìœ 
private RobotAnimator _animator;
private NavMeshAgent _agent;
private Rigidbody _rigidbody;
private RendererController _rendererController;
// ...

// ëª¬ìŠ¤í„° ê´€ë ¨ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì ‘ê·¼
public RobotAnimator Animator => _animator;
public NavMeshAgent Agent => _agent;
public Rigidbody Rigidbody => _rigidbody;
public RendererController RendererController => _rendererController;
// State í´ë˜ìŠ¤ì—ì„œì˜ ì‚¬ìš© ì˜ˆì‹œ:
// controller.Agent.isStopped = true;
// controller.Animator.SetSpeed(0f);

// ...
private void OnEnable()
{
		SetupMonsterStats(); // ìŠ¤í¬ë¦½í„°ë¸” ì˜¤ë¸Œì íŠ¸ì—ì„œ ìŠ¤íƒ¯ ë‹¤ì‹œ ì½ì–´ì˜¤ê¸°
		ResetMonster();      // ëª¬ìŠ¤í„°ì˜ ëª¨ë“  ìƒíƒœë¥¼ ì´ˆê¸°í™”
		FindTarget();        // í”Œë ˆì´ì–´ ë‹¤ì‹œ ì°¾ê¸°
		FaceTarget();        // í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ë°©í–¥ ì „í™˜
		
		ChangeState(MonsterState.Spawn); // í•­ìƒ Spawn ìƒíƒœì—ì„œ ì‹œì‘
}

private void ResetMonster()
{
		StopAllCoroutines(); // ì´ì „ì— ì‹¤í–‰ë˜ë˜ ëª¨ë“  ì½”ë£¨í‹´ ê°•ì œ ì¢…ë£Œ
		// ëª¨ë“  ìƒíƒœ í”Œë˜ê·¸ ì´ˆê¸°í™”
		_isSpawned = false;
		_isDead = false;
		_isKnockedBack = false;
		// ...
		
		// ìì‹ ì½œë¼ì´ë”ë“¤ í™œì„±í™”
		foreach (var col in GetComponentsInChildren<Collider>())
		{
		    col.enabled = true;
		}
		
		// ì• ë‹ˆë©”ì´í„° ìƒíƒœ ì´ˆê¸°í™”
		_animator.RebindAnimator(); // ì• ë‹ˆë©”ì´í„°ë¥¼ ì´ˆê¸° ìƒíƒœë¡œ ë¦¬ì…‹
		
		// ë¬¼ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
		_rigidbody.isKinematic = true;
		_rigidbody.useGravity = false;
		
		// NavMeshAgent ìƒíƒœ ì´ˆê¸°í™”
		_agent.enabled = true;
		_agent.Warp(transform.position); // í˜„ì¬ ìœ„ì¹˜ë¡œ ê°•ì œ ì´ë™
		_agent.ResetPath(); // ì´ì „ ê²½ë¡œ ì‚­ì œ
}
```
<br/>
â‡’ ì™¸ë¶€ ì´ë²¤íŠ¸ ì²˜ë¦¬

```csharp
// In Scripts/SSW/Monster/Refactoring/Core/MonsterControllerRefactored.cs
public class MonsterControllerRefactored : MonoBehaviour, IDamageable
{
		// ...
		private IHitProcessor _hitProcessor;

		// PlayerBulletìœ¼ë¡œë¶€í„° í˜¸ì¶œë˜ëŠ” í”¼ê²© ì´ë²¤íŠ¸ ìˆ˜ì‹  ë©”ì„œë“œ
		public void OnHit(HitData hitData)
		{
		    // 1. í”¼ê²© ê°€ëŠ¥ ìƒíƒœì¸ì§€ í™•ì¸ (ë¬´ì , ì£½ìŒ ìƒíƒœ ë“±)
		    if (!_hitProcessor.CanBeHit(this)) return;
		
		    // 2. í˜„ì¬ ì§„í–‰ ì¤‘ì´ë˜ ëª¨ë“  í–‰ë™(ì½”ë£¨í‹´)ì„ ì¦‰ì‹œ ì¤‘ë‹¨í•˜ì—¬ í”¼ê²©ì— ì¦‰ê° ë°˜ì‘
		    StopAllCoroutines();
		    // ê°ì¢… ì• ë‹ˆë©”ì´ì…˜, ë¬¼ë¦¬ ìƒíƒœ ì´ˆê¸°í™” 
		
		    // 3. ì‹¤ì œ í”¼ê²© ì²˜ë¦¬ëŠ” _hitProcessorì—ê²Œ ìœ„ì„
		    _hitProcessCoroutine = StartCoroutine(_hitProcessor.CoProcessHit(this, hitData));
		}

		// _hitProcessorê°€ í˜¸ì¶œí•˜ëŠ” ë°ë¯¸ì§€ ì²˜ë¦¬ ë©”ì„œë“œ
		public void TakeDamage(float damage)
		{
		    _currentHP -= damage;
		}
}
```
<br/>

- MonsterStateBase.cs
  
  ëª¨ë“  ìƒíƒœ ê°ì²´ê°€ ë”°ë¼ì•¼ í•  ì„¤ê³„ë„ ì—­í• ì„ í•˜ëŠ” ì¶”ìƒ í´ë˜ìŠ¤ ì…ë‹ˆë‹¤.

  OnEnter, OnUpdate, OnExitë¼ëŠ” ëª…í™•í•œ ìƒëª…ì£¼ê¸° ë©”ì„œë“œë¥¼ ì •ì˜í•˜ì—¬ ëª¨ë“  ìƒíƒœê°€ ì¼ê´€ëœ êµ¬ì¡°ë¥¼ ê°–ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤.

  ì´ë¥¼ ìƒì†ë°›ëŠ” ê° ìƒíƒœ í´ë˜ìŠ¤ëŠ” ìì‹ ì˜ ì—­í• ì—ë§Œ ì§‘ì¤‘í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/SSW/Monster/Refactoring/States/MonsterStateBase.cs
public abstract class MonsterStateBase
{
	protected MonsterControllerRefactored controller; // ìƒíƒœë¥¼ ì†Œìœ í•œ ì»¨íŠ¸ë¡¤ëŸ¬ ì°¸ì¡°
	protected MonsterState stateType;

	public MonsterStateBase(MonsterControllerRefactored controller, MonsterState stateType)
	{
	    this.controller = controller;
	    this.stateType = stateType;
	}

	// ìƒíƒœê°€ ì‹œì‘ë  ë•Œ í•œ ë²ˆ í˜¸ì¶œë˜ëŠ” ì´ˆê¸°í™” ë©”ì„œë“œ
	public virtual void OnEnter() { }
	
	// ìƒíƒœê°€ í™œì„±í™”ëœ ë™ì•ˆ ë§¤ í”„ë ˆì„ í˜¸ì¶œë˜ëŠ” ì—…ë°ì´íŠ¸ ë©”ì„œë“œ
	public virtual void OnUpdate() { }
	
	// ìƒíƒœê°€ ì¢…ë£Œë  ë•Œ í•œ ë²ˆ í˜¸ì¶œë˜ëŠ” ì •ë¦¬ ë©”ì„œë“œ
	public virtual void OnExit() { }
}
```
<br/>

- ChaseState.cs (ìƒíƒœ êµ¬í˜„ ì˜ˆì‹œ)

  MonsterStateBaseë¥¼ ìƒì†ë°›ì•„ ì‹¤ì œ í–‰ë™ ë¡œì§ì„ êµ¬í˜„í•œ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

  ìƒíƒœ ì „í™˜ ì¡°ê±´ì´ ë§Œì¡±ë˜ë©´ ì‹¤í–‰ë˜ë©°, ì„œë¡œê°„ì˜ ìƒíƒœì— ëŒ€í•´ ì•Œ í•„ìš” ì—†ì´ ìš”ì²­ì„ í†µí•´ ì´ëŸ¬í•œ í–‰ë™ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/Monster/Refactoring/States/ChaseState.cs
public class ChaseState : MonsterStateBase
{
		public ChaseState(MonsterControllerRefactored controller) : base(controller, MonsterState.Chase) { }
		public override void OnEnter()
		{
		    base.OnEnter();
		    controller.Agent.isStopped = false; // ì¶”ì  ì‹œì‘
		}
		
		public override void OnUpdate()
		{
		    base.OnUpdate();
		    controller.Agent.SetDestination(controller.Target.position); // ë§¤ í”„ë ˆì„ ëª©í‘œ ìœ„ì¹˜ ê°±ì‹ 
		
		    // ìƒíƒœ ì „í™˜ ì¡°ê±´ ê²€ì‚¬
		    float sqrDistToTarget = (controller.transform.position - controller.Target.position).sqrMagnitude;
		    if (sqrDistToTarget <= controller.AttackRange * controller.AttackRange)
		    {
		        // ì¡°ê±´ ë§Œì¡± ì‹œ, ì»¨íŠ¸ë¡¤ëŸ¬ì— ìƒíƒœ ë³€ê²½ ìš”ì²­
		        controller.ChangeState(MonsterState.Attack);
		    }
		}
		
		public override void OnExit()
		{
		    base.OnExit();
		    if (controller.Agent.isOnNavMesh)
		    {
		        controller.Agent.isStopped = true; // ì¶”ì  ì¢…ë£Œ ë° ì •ì§€
		        controller.Agent.ResetPath();
		    }
		}
}
```

<br/><br/>

#### B. ë³´ìŠ¤ ëª¬ìŠ¤í„° AI: Behavior Tree

ìì‹ ì˜ ìƒíƒœ ê·¸ë¦¬ê³  ì£¼ë³€ ì •ë³´ë¥¼ í†µí•´ ì—¬ëŸ¬ ì¡°ê±´ì„ í‰ê°€í•˜ê³  í–‰ë™ì˜ ìš°ì„ ìˆœìœ„ë¥¼ ê²°ì •í•´ì•¼ í•˜ë©°, ì˜ì‚¬ê²°ì •ì„ ë‚´ë¦´ ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

ì´ë•Œ, FSM êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ìƒíƒœ ê°„ì˜ ì „ì´ ì¡°ê±´ì´ ë³µì¡í•´ì§€ë©°, ë””ë²„ê¹… ì‹œ ì¶”ì ì´ ì–´ë ¤ì›Œì§ˆ ê²ƒìœ¼ë¡œ ìƒê°í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´, ë” ìœ ì—°í•œ íŒë‹¨ì„ í•  ìˆ˜ ìˆëŠ” Behavior Tree êµ¬ì¡°ë¥¼ ì°¾ì•„ ì´ë¥¼ ì ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.

##### B - 1. ì•„í‚¤í…ì²˜ì˜ 4ê°œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

- BossBTController

  BT ë…¸ë“œë“¤ì„ ì¡°ë¦½í•˜ì—¬ ë³´ìŠ¤ì˜ ì „ì²´ í–‰ë™ íŒ¨í„´ì„ ì™„ì„±í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

  Start()ì—ì„œ ë…¸ë“œë“¤ì˜ ì¡°í•©ì„ í†µí•´ ì˜ì‚¬ê²°ì • êµ¬ì¡° ì „ì²´ë¥¼ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
// In Scripts/SSW/BossMonster/Base/BossBTController.cs
public class BossBTController : MonoBehaviour
{
		private BTNode _rootNode; // í–‰ë™ íŠ¸ë¦¬ì˜ ìµœìƒìœ„ ì‹œì‘ì 
		// ...
		void Start()
		{
		    // ë³´ìŠ¤ì˜ í–‰ë™ ë¡œì§
		    _rootNode = new SequenceNode(_blackboard, new List<BTNode>
		    {
		        // 1: ìƒì¡´ í™•ì¸ í•­ìƒ ê°€ì¥ ë¨¼ì € ì‹¤í–‰, ì‹¤íŒ¨ ì‹œ(ì£½ì—ˆìœ¼ë©´) ëª¨ë“  í–‰ë™ ì¤‘ë‹¨
		        new CheckIfDeadNode(_blackboard),
		
		        // 2: í–‰ë™ ì„ íƒ, ì•„ë˜ íŒ¨í„´ ì¤‘ í•˜ë‚˜ê°€ ì„±ê³µí•  ë•Œê¹Œì§€ ìˆœì„œëŒ€ë¡œ ì‹œë„
		        new SelectorNode(_blackboard, new List<BTNode>
		        {
		            // íŒ¨í„´ 1: í”Œë ˆì´ì–´ê°€ ê°€ê¹ê³ (10m ì´í•˜), ë¬´ê¸°ê°€ í•˜ë‚˜ë¼ë„ ì‚´ì•„ìˆì„ ë•Œ
		            new SequenceNode(_blackboard, new List<BTNode>
		            {
		                new CheckPlayerDistanceNode(_blackboard, 10f, ComparisonMode.LessThanOrEqual),
		                new CheckWeaponAliveNode(_blackboard),
		                new MoveToTargetNode(_blackboard, _agent, _blackboard.Target), // ì ‘ê·¼
		                new RotateTowardsTargetNode(_blackboard, _agent),               // ì¡°ì¤€
		                new ParallelNode(_blackboard, new List<BTNode>                  // ë™ì‹œ ì‹¤í–‰ ë…¸ë“œ
		                {
		                    new LookAroundNode(_blackboard, _agent),                    // ì£¼ë³€ì„ ë‘˜ëŸ¬ë³´ë©´ì„œ
		                    new RepeatShootNode(_blackboard, _agent)                    // ì´ì•Œ ë°œì‚¬
		                })
		            }),
		
		            // íŒ¨í„´ 2: í”Œë ˆì´ì–´ê°€ ê°€ê¹ì§€ë§Œ, ë¬´ê¸°ê°€ ëª¨ë‘ íŒŒê´´ë˜ì—ˆì„ ë•Œ
		            new SequenceNode(_blackboard, new List<BTNode>
		            {
		                new CheckPlayerDistanceNode(_blackboard, 10f, ComparisonMode.LessThanOrEqual),
		                new MoveToTargetNode(_blackboard, _agent, _blackboard.Target), // ì ‘ê·¼
		                new ParallelNode(_blackboard, new List<BTNode>                  // ë™ì‹œ ì‹¤í–‰ ë…¸ë“œ
		                {
		                    new LookAroundNode(_blackboard, _agent),                    // ì£¼ë³€ì„ ë‘˜ëŸ¬ë³´ë©´ì„œ
		                    new RepeatSpawnAreaAttackNode(_blackboard, _blackboard.AreaAttackPrefab) // ì›ê±°ë¦¬ ì¥íŒ ê³µê²© ì‹œì „
		                })
		            }),
		
		            // íŒ¨í„´ 3: í”Œë ˆì´ì–´ê°€ ë©€ë¦¬ ìˆì„ ë•Œ (ìœ„ íŒ¨í„´ë“¤ì´ ëª¨ë‘ ì‹¤íŒ¨í–ˆì„ ë•Œ ì‹¤í–‰)
		            new SequenceNode(_blackboard, new List<BTNode>
		            {
		                new CheckPlayerDistanceNode(_blackboard, 10f, ComparisonMode.GreaterThan),
		                new ParallelNode(_blackboard, new List<BTNode>                  // ë™ì‹œ ì‹¤í–‰ ë…¸ë“œ
		                {
		                    new PatrolNode(_blackboard, _agent, _blackboard.PatrolPoints),      // ìˆœì°°
		                    new RepeatSpawnAreaAttackNode(_blackboard, _blackboard.AreaAttackPrefab) // ì›ê±°ë¦¬ ì¥íŒ ê³µê²© ì‹œì „
		                })
		            })
		        })
		    });
		}
		
		void Update()
		{
		    // ë§¤ í”„ë ˆì„, í–‰ë™ íŠ¸ë¦¬ì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ì‹¤í–‰ì‹œì¼œ ì˜ì‚¬ê²°ì • ì‚¬ì´í´ì„ ë°˜ë³µ
		    _rootNode?.Tick();
		}

}
```
<br/>

- BTNode.cs

  í–‰ë™ íŠ¸ë¦¬ì˜ ê°€ì¥ ê¸°ë³¸ì  êµ¬ì„± ìš”ì†Œì¸ ë…¸ë“œì˜ ì¶”ìƒ í´ë˜ìŠ¤ì…ë‹ˆë‹¤.

  ì´ë¥¼ í†µí•´ì„œ, ëª¨ë“  ë…¸ë“œëŠ” Tick()ìœ¼ë¡œ ì‹¤í–‰ ì‹ í˜¸ë¥¼ ë°›ìœ¼ë©°, ìì‹ ì˜ ë¡œì§ì„ ìˆ˜í–‰í•œ í›„, Success, Failure, Running ì¤‘ í•˜ë‚˜ì˜ ìƒíƒœë¥¼ ë¶€ëª¨ì—ê²Œ ë°˜í™˜í•©ë‹ˆë‹¤.

  OnEnterì™€ OnExitë¥¼ í†µí•´ ë…¸ë“œ ì‹¤í–‰ ì „í›„ì˜ ì´ˆê¸°í™” ë° ì •ë¦¬ ì‘ì—…ì„ í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/BossMonster/Base/BTNode.cs

  public enum NodeState{ Success, Failure, Running }

  public abstract class BTNode
  {
      protected NodeState _state = NodeState.Running; // Default state
      protected BTBlackboard _blackboard; // ëª¨ë“  ë…¸ë“œê°€ ê³µìœ í•˜ëŠ” ë°ì´í„° ì €ì¥ì†Œ

      private bool _entered = false;
      public NodeState State => _state;
      public BTNode(BTBlackboard blackboard)
      {
          _blackboard = blackboard;
      }

      public NodeState Tick()
      {
          if (!_entered) // ë…¸ë“œê°€ ì²˜ìŒ ì‹¤í–‰ë  ë•Œ
          {
              _entered = true;
              _state = NodeState.Running;
              OnEnter();
          }

          _state = Evaluate();

          if (_state != NodeState.Running) // ë…¸ë“œ ì‹¤í–‰ì´ ì™„ë£Œë˜ì—ˆì„ ë•Œ (ì„±ê³µ ë˜ëŠ” ì‹¤íŒ¨)
          {
              OnExit();
              _entered = false;
          }

          return _state;
      }
      
			// ì‹¤ì œ ë¡œì§ì´ êµ¬í˜„ë˜ëŠ” ì¶”ìƒ ë©”ì„œë“œ
      public abstract NodeState Evaluate();
      protected virtual void OnEnter() {}
      protected virtual void OnExit() {}

      public virtual void OnAbort()
      {
          if (_entered)
          {
              OnExit();
              _entered = false;
              _state = NodeState.Failure;
          }
      }
  }

```
<br/>

- BTBlackboard.cs

  ë³´ìŠ¤ AIì˜ ëª¨ë“  ìƒíƒœë¥¼ ì €ì¥í•˜ë©°, í•´ë‹¹ ì •ë³´ë¥¼ ì°¸ì¡°í•˜ë©° ê³µìœ í•˜ê²Œ ë©ë‹ˆë‹¤.

  ë˜í•œ, ì™¸ë¶€ë¡œë¶€í„° Hitë  ë•Œ, ë¶€ìœ„ ë³„ íŒŒê´´ ì‹œìŠ¤í…œ ë˜í•œ ì—¬ê¸°ì„œ ê´€ë¦¬í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/BossMonster/Base/BTBlackboard.cs
    public class BTBlackboard : MonoBehaviour
    {
        [Header("Patrol Settings")]
        [SerializeField] private Transform[] _patrolPoints; // ìˆœì°° ìœ„ì¹˜ ì§€ì •

        [Header("Attack Settings")]
        [SerializeField] private Transform _leftBulletSpawnPoint;
        [SerializeField] private Transform _rightBulletSpawnPoint;
        [SerializeField] private GameObject _areaAttackPrefab;
        [SerializeField] private GameObject _bulletPrefab;
        [SerializeField] private float _bulletSpeed = 5f; // default ìˆ˜ì¹˜
        [SerializeField] private float _particleDelay = 0.5f; // default ìˆ˜ì¹˜

        #region Runtime Variables
        // ë³´ìŠ¤ì˜ í•µì‹¬ ìŠ¤í…Ÿ ë° ëŸ°íƒ€ì„ ìƒíƒœ ë°ì´í„°
        private int _currentHP;
        private bool _isDead = false;
        private Transform _target;
        private int _currentPatrolIndex;
        #endregion

        #region Methods
        public void Initialize()
        {
            _currentHP = _maxHP;
            _isDead = false;
            _currentPatrolIndex = 0;
            // ...
        }

        public void TakeDamage(int damage, BossHitBoxType partType)
        {
            if (_isDead) return;
						// ë¶€ìœ„ë³„ HP ê°ì†Œ ë° ìƒíƒœ ë³€ê²½
            switch (partType)
            {
                case BossHitBoxType.Body:
                    _currentHP -= damage;
                    break;
                case BossHitBoxType.LeftArm:
                    _WeaponLeftHP -= damage;
                    if (_WeaponLeftHP < 0) _WeaponLeftHP = 0;
                    break;
                case BossHitBoxType.RightArm:
                    _WeaponRightHP -= damage;
                    if (_WeaponRightHP < 0) _WeaponRightHP = 0;
                    break;
            }
       
            if (_currentHP <= 0)
            {
                _currentHP = 0;
                if (_WeaponLeftHP > 0)
                {
                    _WeaponLeftHP = 0;
                }
                if (_WeaponRightHP > 0)
                {
                    _WeaponRightHP = 0;
                }
                _deathHandler?.TriggerDeath();
            }
        }

        public void SetNextPatrolPoint() // ìˆœì°° ë…¸ë“œì—ì„œ ì ‘ê·¼í•  ìœ„ì¹˜
        {
            if (_patrolPoints == null || _patrolPoints.Length == 0) return;

            _currentPatrolIndex = (_currentPatrolIndex + 1) % _patrolPoints.Length;
        }
        #endregion
        
        
        #region Properties
        public int MaxHP => _maxHP;
        public int CurrentHP => _currentHP;
        public float HealthPercentage => (float)_currentHP / _maxHP;
        public float MoveSpeed => _moveSpeed;
        public float AttackCooldown => _attackCooldown;
        public Transform[] PatrolPoints => _patrolPoints;
        public Transform LeftBulletSpawnPoint => _leftBulletSpawnPoint;
        public Transform RightBulletSpawnPoint => _rightBulletSpawnPoint;
        public GameObject BulletPrefab => _bulletPrefab;
        public float BulletSpeed => _bulletSpeed;
        public float ParticleDelay => _particleDelay;
        public Transform Target => _target;
        public int CurrentPatrolIndex
        {
            get => _currentPatrolIndex;
            set => _currentPatrolIndex = value;
        }
        public bool IsDead
        {
            get => _isDead;
            set => _isDead = value;
        }
        public BossPhase CurrentPhase => _currentPhase;
        public RobotAnimator RobotAnimator => _robotAnimator;
        public int WeaponLeftHP => _WeaponLeftHP;
        public int WeaponRightHP => _WeaponRightHP;
        public GameObject AreaAttackPrefab => _areaAttackPrefab;
        public DeathHandler DeathHandler => _deathHandler;
        public BossAudioController BossAudioController => _bossAudioController;
        #endregion
    }
}
```

##### B - 2. ë…¸ë“œì˜ ìƒí˜¸ì‘ìš©

- Composite ë…¸ë“œì— í•´ë‹¹í•˜ëŠ” Sequence Nodeì—ì„œ ë¬´ê¸°ì˜ íŒŒê´´ ì—¬ë¶€ì— ë”°ë¼ ê³µê²©ì„ ê²°ì •í•˜ëŠ” ë¶€ë¶„ì´ ìˆìŠµë‹ˆë‹¤. ì´ì²˜ëŸ¼, ë…¸ë“œë“¤ë¼ë¦¬ ìƒí˜¸ì‘ìš©ì„ í†µí•´ ì§€ëŠ¥ì ì¸ í–‰ë™ì„ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```csharp
new SequenceNode(_blackboard, new List<BTNode>
{
		// ...
		new CheckWeaponAliveNode(_blackboard),   // [ì¡°ê±´] ë¬´ê¸°ê°€ ì‚´ì•„ìˆëŠ”ì§€ ê²€ì‚¬
		new RepeatShootNode(_blackboard, _agent) // [í–‰ë™] ì‚´ì•„ìˆë‹¤ë©´, ì´ì„ ë°œì‚¬
		// ...
})
```

```csharp
// In Scripts/SSW/BossMonster/BossBulletSpawner/CheckWeaponAliveNode.cs
public class CheckWeaponAliveNode : BTNode
{
		public CheckWeaponAliveNode(BTBlackboard blackboard) : base(blackbord) { }
		
		public override NodeState Evaluate()
		{
		    // ë¸”ë™ë³´ë“œë¥¼ í†µí•´ í˜„ì¬ ë³´ìŠ¤ì˜ ìƒíƒœë¥¼ ì¡°íšŒ
		    if (_blackboard.IsDead) return NodeState.Failure; // ì£½ì—ˆìœ¼ë©´ ë¬´ì¡°ê±´ ì‹¤íŒ¨
		
		    // ë¸”ë™ë³´ë“œì—ì„œ ì–‘ìª½ ë¬´ê¸°ì˜ í˜„ì¬ ì²´ë ¥ ì •ë³´ë¥¼ ê°€ì ¸ì˜´
		    bool leftDestroyed = _blackboard.WeaponLeftHP == 0;
		    bool rightDestroyed = _blackboard.WeaponRightHP == 0;
		
		    // ë‘ ë¬´ê¸°ê°€ ëª¨ë‘ íŒŒê´´ë˜ì—ˆë‹¤ë©´, ì‹¤íŒ¨(Failure)ë¥¼ ë°˜í™˜
		    if (leftDestroyed && rightDestroyed)
		    {
		        return NodeState.Failure;
		    }
		
		    // í•˜ë‚˜ë¼ë„ ì‚´ì•„ìˆë‹¤ë©´, ì„±ê³µ(Success)ì„ ë°˜í™˜
		    return NodeState.Success;
		}
}
```

```csharp
// In Scripts/SSW/BossMonster/Base/RepeatShootNode.cs
public class RepeatShootNode : BTNode
{
		private Timer _shootTimer;
		private readonly float _shootInterval = 0.3f;
		private string _poolKey = "Boss_BulletAttack";
		
		public RepeatShootNode(BTBlackboard blackboard, NavMeshAgent agent) : base(blackboard)
		{
		    _shootTimer = new Timer(_shootInterval);
		}
		
		// OnEnter: ë…¸ë“œê°€ ì²˜ìŒ í™œì„±í™”ë  ë•Œ íƒ€ì´ë¨¸ë¥¼ ë¦¬ì…‹
		protected override void OnEnter()
		{
		    _shootTimer.Reset();
		}
		
		// Evaluate: ë§¤ í”„ë ˆì„ ì‹¤í–‰ë˜ëŠ” í•µì‹¬ ë¡œì§
		public override NodeState Evaluate()
		{
		    // 1. ë¸”ë™ë³´ë“œë¥¼ í†µí•´ ì£½ì—ˆëŠ”ì§€ íŒë‹¨í•˜ì—¬ ì‹¤íŒ¨ ì¡°ê±´ í™•ì¸
		    if (_blackboard.Target == null || _blackboard.IsDead)
		    {
		        return NodeState.Failure;
		    }
		
		    // 2. íƒ€ì´ë¨¸ê°€ ëë‚¬ëŠ”ì§€ í™•ì¸
		    if (_shootTimer.IsFinished())
		    {
		        Shoot(); // ì‹¤ì œ ë°œì‚¬ ë¡œì§ ì‹¤í–‰
		        _shootTimer.Reset(); // íƒ€ì´ë¨¸ ì´ˆê¸°í™”
		    }
		
		    // 3. ì´ ë…¸ë“œëŠ” ë¶€ëª¨ ë…¸ë“œê°€ ì¤‘ë‹¨ì‹œí‚¤ê¸° ì „ê¹Œì§€ ê³„ì† ì‹¤í–‰ë˜ì–´ì•¼ í•˜ë¯€ë¡œ, í•­ìƒ Runningì„ ë°˜í™˜
		    return NodeState.Running;
		}
		
		private void Shoot()
		{
		    // 4. ë°œì‚¬ ì§ì „, ë‹¤ì‹œ ë¸”ë™ë³´ë“œë¥¼ í†µí•´ ì™¼ìª½ ë¬´ê¸°ê°€ ì‚´ì•„ìˆëŠ”ì§€ íŒë‹¨
		    if (_blackboard.WeaponLeftHP > 0 && _blackboard.LeftBulletSpawnPoint != null)
		    {
		        // 5. ê²Œì„ ì›”ë“œì™€ ìƒí˜¸ì‘ìš© (ì˜¤ë””ì˜¤ ì¬ìƒ, ì´ì•Œ ìƒì„±)
		        _blackboard.BossAudioController.PlayAttackLeftSound();
		        FireBullet(_blackboard.LeftBulletSpawnPoint);
		    }
		    // ...
		}
		
		private void FireBullet(Transform spawnPoint)
		{
		    // 6. ë‹¤ë¥¸ ì‹œìŠ¤í…œ(PoolManager)ê³¼ ìƒí˜¸ì‘ìš©í•˜ì—¬ ì‹¤ì œ ì´ì•Œ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ì ¸ì˜´
		    GameObject bullet = PoolManager.Instance.GetFromPool(_poolKey);
		    // ... ì´ì•Œ ìœ„ì¹˜ ë° ì†ë„ ì„¤ì •
		}
}
```

#### C - ê²°ê³¼

- FSMì˜ ì¥ì ê³¼ í•œê³„: FSMì€ ìƒíƒœê°€ ëª…í™•í•˜ê²Œ êµ¬ë¶„ë˜ê³  ì „ì´ ì¡°ê±´ì´ ë‹¨ìˆœí•  ë•Œ, ê°€ë…ì„±ì´ ë†’ê³  ì•ˆì •ì ì¸ ì½”ë“œë¥¼ ë§Œë“¤ ìˆ˜ ìˆì§€ë§Œ, ìƒíƒœ ê°œìˆ˜ë‚˜ ìˆ˜í–‰í•´ì•¼ í•  ë™ì‘ë“¤ì´ ëŠ˜ì–´ë‚˜ê²Œ ë˜ë©´ì„œ ë³µì¡í•´ì ¸ ìˆ˜ì •í•˜ê¸° ì–´ë ¤ì›Œì§„ë‹¤ëŠ” ë¬¸ì œì ì´ ìˆì—ˆìŠµë‹ˆë‹¤.
- Behavior Treeì˜ íŠ¹ì§•: ì´ˆê¸° ì„¤ê³„ ë¹„ìš©ì˜ ê²½ìš° FSM ë³´ë‹¤ ë†’ê³  êµ¬í˜„ ë‚œì´ë„ ë˜í•œ ë†’ë‹¤ê³  ëŠê»´ì¡Œì§€ë§Œ, í•œ ë²ˆ ì‹œìŠ¤í…œì„ ë§Œë“¤ê³  ë‚˜ë©´ ë‹¨ìˆœíˆ ë³´ìŠ¤ ëª¬ìŠ¤í„° ë¿ë§Œ ì•„ë‹ˆë¼ ì—¬ëŸ¬ ì‹œìŠ¤í…œì— ì ìš©ì‹œí‚¬ ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ë˜í•œ ë…¸ë“œ ê°„ì˜ ë¬¶ìŒìœ¼ë¡œ ì—°ì‡„ì‘ìš©ì„ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì´ìš©í•œ í™•ì¥ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œë˜ì—ˆìŠµë‹ˆë‹¤.

<br/>

---

### 2. ê²Œì„ í”Œë ˆì´ ì‹œìŠ¤í…œ: ì „ëµ íŒ¨í„´ê³¼ ì±…ì„ ë¶„ë¦¬

ì´ í”„ë¡œì íŠ¸ëŠ” ë‹¨ìˆœíˆ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì—ì„œ ê·¸ì¹˜ì§€ ì•Šê³ , ê°œë°œ ê³¼ì •ì—ì„œ ë§ˆì£¼ì¹œ ë¬¸ì œë“¤ì„ ë” ë‚˜ì€ ì„¤ê³„ë¡œ í•´ê²°í•´ë‚˜ê°€ëŠ” ë¦¬íŒ©í† ë§ì˜ ì—°ì†ì´ì—ˆìŠµë‹ˆë‹¤. íŠ¹íˆ ìƒˆë¡œìš´ ì½˜í…ì¸ ë‚˜ ê¸°ëŠ¥ì„ ì¶”ê°€í•  ë•Œ ì–´ë–»ê²Œ í•˜ë©´ ë” ê°„ë‹¨í•˜ê³  ì•ˆì „í•˜ê²Œ ì¶”ê°€í•  ìˆ˜ ìˆëŠ”ì§€ ê³ ë¯¼í•˜ëŠ” ê¸°íšŒê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. í•´ë‹¹ ì˜ˆì‹œë¡œ ì „ëµ íŒ¨í„´ê³¼ ê° í´ë˜ìŠ¤ ë³„ ì±…ì„ ë¶„ë¦¬ê°€ ìˆìŠµë‹ˆë‹¤.

#### A. ê³µê²© ë¡œì§: God Classì—ì„œ Strategy Patternìœ¼ë¡œ ë³€í™”

##### A - 1. ì´ˆê¸° ì„¤ê³„ì˜ ë¬¸ì œì 

ì•ì„œ ë“±ì¥í•œ MonsterController.csì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ì—ì„œ ëª¨ë‘ ê´€ë¦¬í•˜ë©° ì´ ë°©ì‹ì€ ê²°êµ­, ìˆ˜ì •í•  ì‹œ ë‹¤ë¥¸ ê¸°ëŠ¥ë“¤ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆê³ , ëª¬ìŠ¤í„° ë³„ë¡œ ì¡°ê±´ë¬¸ì„ ì§œê±°ë‚˜ ë¶ˆí•„ìš”í•˜ê²Œ ë˜‘ê°™ì€ ì½”ë“œë¥¼ ìƒì„±í•´ì•¼ í•œë‹¤ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤.

##### A - 2. ê³µê²© í–‰ìœ„ ë¶„ë¦¬

ìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´, ëª¬ìŠ¤í„°ì˜ ê³µê²© í–‰ìœ„ë¥¼ ëª¬ìŠ¤í„° í´ë˜ìŠ¤ë¡œë¶€í„° ë¶„ë¦¬í•˜ì—¬, êµì²´ ê°€ëŠ¥í•œ ëª¨ë“ˆë¡œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.
<br/>

- AttackSO.cs

  ëª¨ë“  ê³µê²© ëª¨ë“ˆì´ ë”°ë¼ì•¼ í•˜ëŠ” ì„¤ê³„ë„ë¡œ, ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.

  ëª¨ë“  ê³µê²©ì€ CoExecute ì‹¤í–‰ ë©”ì„œë“œë¥¼ ê°€ì ¸ì•¼ í•˜ë©°, ê³µê²© ë²”ìœ„, ì¿¨íƒ€ì„, ë”œë ˆì´, ë°ë¯¸ì§€ì™€ ê°™ì€ ê³µí†µ ì†ì„±ì„ ì •ì˜í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/SSW/Monster/Refactoring/Attack/AttackSO.cs
public abstract class AttackSO : ScriptableObject
{
    [Header("Common Attack Stats")]
    public float attackRange = 10f;
    public float attackCooldown = 3f;
    public float attackDelay = 0.5f;
    public int _attackDamage = 10;

    // This is the core method that executes the attack logic.
    // 'owner' is the monster that is performing this attack.
    public abstract IEnumerator CoExecute(MonsterControllerRefactored owner);
}
```
<br/>

- Rob01AttackSO.cs (êµ¬í˜„ì²´)

 ê¸°ì¡´ MonsterController.csì— ìˆë˜ ëª¬ìŠ¤í„°ì˜ ê³µê²© ë¡œì§ì„ ë—´ì–´ë‚´ì–´ ScriptableObjectë¡œ ë§Œë“¤ì—ˆìœ¼ë©°, ìì‹ ì˜ ê³µê²© ë°©ì‹ì— ì§‘ì¤‘í•˜ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/SSW/Monster/Refactoring/Attack/Rob01AttackSO.cs

[CreateAssetMenu(fileName = "Rob01Attack", menuName = "ScriptableObjects/Attack/Rob01Attack")]
public class Rob01AttackSO : AttackSO
{
    [Header("Ranged Specific Stats")]
    public string bulletKey = "MonsterBullet";
    public float bulletSpeed = 5f;
    public override IEnumerator CoExecute(MonsterControllerRefactored owner)
    {
        Rob01AttackHandler attackHandler = owner.GetComponent<Rob01AttackHandler>();
        if (attackHandler == null)
        {
            yield break;
        }

        owner.Animator.SetShoot(true);
        yield return new WaitForSeconds(attackDelay);

        FireBulletFrom(attackHandler.BulletSpawnPointLeft);
        FireBulletFrom(attackHandler.BulletSpawnPointRight);
    }

    private void FireBulletFrom(Transform spawnPoint)
    {
        if (spawnPoint == null) return;

        GameObject bullet = PoolManager.Instance.GetFromPool(bulletKey);
        if (bullet != null)
        {
            bullet.transform.position = spawnPoint.position;
            bullet.transform.rotation = spawnPoint.rotation;
            MonsterBullet monsterBullet = bullet.GetComponent<MonsterBullet>();
            if (monsterBullet != null)
            {
                monsterBullet.Initialize(_attackDamage);
            }

            if (bullet.TryGetComponent(out Rigidbody rb_bullet))
            {
                rb_bullet.velocity = Vector3.zero; // Reset velocity before applying new one
                rb_bullet.angularVelocity = Vector3.zero; // Reset angular velocity
                rb_bullet.velocity = spawnPoint.forward * bulletSpeed;
            }
        }
    }
}

```
<br/><br/>
#### B. í”¼ê²© ì‹œìŠ¤í…œ: ê¸°ëŠ¥ ë³„ ì±…ì„ ë¶„ë¦¬

##### B - 1. ì´ˆê¸° ì„¤ê³„ì˜ ë¬¸ì œì 

ì´ˆê¸°ì—ëŠ” PlayerBulletì´ MonsterControllerì˜ OnHitì„ ì§ì ‘ í˜¸ì¶œì‹œí‚¤ëŠ” ë‹¨ìˆœí•œ êµ¬ì¡°ì˜€ìŠµë‹ˆë‹¤. ë„‰ë°± ë˜í•œ ê¸°ë³¸ê³µê²©ì—ë„ ì¡´ì¬í–ˆì§€ë§Œ, ê°œë°œ ë‹¨ê³„ì—ì„œ ê¸°íšì´ ë³€ê²½ë˜ë©° ë³´ìŠ¤ì˜ íŠ¹ì • ë¶€ìœ„ íƒ€ê²©, ìŠ¤í‚¬ ê³µê²©ì— ë„‰ë°± ë“±ì´ ìƒê²¨ ë§¤ê°œ ë³€ìˆ˜ ì¦ê°€ ë° ë³„ë„ì˜ í•¨ìˆ˜ ì²˜ë¦¬ê°€ í•„ìš”í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

<br/>

##### B - 2. í‘œì¤€í™”ë¥¼ ìœ„í•œ êµ¬ì¡°ì²´ ë„ì… ë° ì±…ì„ ë¶„í• 

- HitData.cs

 í”¼ê²©ì— ê´€í•œ ëª¨ë‘ ì •ë³´ë¥¼ ë‹´ëŠ” êµ¬ì¡°ì²´ ì—­í• ì„ í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/HitSystem/Data/HitData.cs
public struct HitData
{
      public float damage;
      public float knockbackForce; 
      public Vector3 knockbackDirection;
      public Vector3 hitPoint;
      public string attackType;
      public BossHitBoxType? partType;

      // Constructor for convenience
      public HitData(float damage, float knockbackForce, Vector3 knockbackDirection, Vector3 hitPoint, string attackType = "Normal", BossHitBoxType? partType = null)
      {
          this.damage = damage;
          this.knockbackForce = knockbackForce;
          this.knockbackDirection = knockbackDirection;
          this.hitPoint = hitPoint;
          this.attackType = attackType;
          this.partType = partType;
      }
  }
```
<br/>

- IDamageable Interface í™œìš©

  í”¼ê²©ë  ìˆ˜ ìˆëŠ” ëª¨ë“  ê°ì²´ëŠ” IDamageable ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†ë°›ë„ë¡ êµ¬í˜„í•˜ì—¬, OnHitë¥¼ ê°–ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

  ë³´ìŠ¤ ëª¬ìŠ¤í„°ì˜ ê²½ìš° IDamageableë¥¼ BossHitHandlerì—ì„œ ë°›ì•„ ì²˜ë¦¬í•˜ê³  ìˆìŠµë‹ˆë‹¤.

```csharp
public interface IDamageable
{
    void OnHit(HitData hitData);
}
```
<br/>

- MonsterHitProcessor.cs

  Structë‚´ìš©ì„ ë¶„ì„í•˜ê³  ë°ë¯¸ì§€ ì ìš©, ìƒíƒœ ë³€ê²½, ë„‰ë°± ì—¬ë¶€ íŒë‹¨ ê·¸ë¦¬ê³  ì„¸ë¶€ ë¡œì§ê¹Œì§€ ëª¨ë‘ ì±…ì„ì§€ê³  ìˆ˜í–‰í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/HitSystem/Processors/MonsterHitProcessor.cs
public class MonsterHitProcessor : IHitProcessor
{
		public IEnumerator CoProcessHit(MonsterControllerRefactored controller, HitData hitData)
		{
				controller.ChangeState(MonsterState.Hit);
				controller.TakeDamage(hitData.damage);
				// ...
				if (ShouldApplyKnockback(controller, hitData)) // ë„‰ë°± ê·œì¹™ì€ ì˜¤ì§ MonsterHitProcessorë§Œ ì•Œê³  ìˆìŒ
				{
						yield return controller.StartCoroutine(CoProcessKnockback(controller, hitData));
				}
				// ...
		}
}
```

<br/>

---

### 3. ì„±ëŠ¥ ìµœì í™”

VR ê²Œì„ì€ ì•„ì£¼ ì‘ì€ í”„ë ˆì„ ì €í•˜ë„ ì‚¬ìš©ìì—ê²Œ ì§ì ‘ì ì¸ ë©€ë¯¸ì™€ ë¶ˆì¾Œê°ì„ ìœ ë„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—, ì•ˆì •ì ì¸ ì„±ëŠ¥ í™•ë³´ê°€ í•„ìš”í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ ë‹¨ìˆœíˆ ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì—ì„œ ëë‚˜ì§€ ì•Šê³  ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œ ì§€ì›í•˜ëŠ” í”„ë¡œíŒŒì¼ë§ ë° ìµœì í™” ë°©ë²•ë“¤ì— ëŒ€í•´ ë‹¤ì–‘í•˜ê²Œ ì•Œ ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ ì‹œë„í–ˆë˜ ê²ƒë“¤ ì¤‘ ê²Œì„ ì„¤ëª… ì˜ìƒì—ì„œ ìì„¸íˆ ê¸°ì¬í•˜ì§€ ëª»í•œ Object Pooling ì½”ë“œ, ê·¸ë¦¬ê³  ìµœì¢…ì ìœ¼ë¡œ ì¢‹ì€ ê²°ê³¼ë¥¼ ë‚´ì§€ëŠ” ëª»í–ˆì§€ë§Œ ì‹œë„í–ˆë˜ ë¬¼ë¦¬ ì—°ì‚° ë¶€í•˜ë¥¼ ì¤„ì´ëŠ” ì‹œë„ì— ëŒ€í•´ ê¸°ìˆ í•˜ì˜€ìŠµë‹ˆë‹¤.

#### A. ì˜¤ë¸Œì íŠ¸ í’€ë§(Object Pooling) ì‹œìŠ¤í…œ êµ¬ì¶•ì„ í†µí•œ GC ìµœì í™”

##### A - 1. ì´ˆê¸° ì„¤ê³„

ê²Œì„ ë‚´ì— ì—¬ëŸ¬ ì°¨ë¡€ ë“±ì¥í•˜ëŠ” ì´ì•Œ, ëª¬ìŠ¤í„°, íŒŒí‹°í´ ì´í™íŠ¸ ê°™ì€ ë™ì¼ ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•´ ì§§ì€ ì‹œê°„ ë™ì•ˆ ìƒì„±ë˜ê³  íŒŒê´´ë˜ëŠ” ê²½ìš°, Instantiateì˜ ë°˜ë³µì ì¸ í˜¸ì¶œë¡œ í”Œë ˆì´ì–´ê°€ ì²´ê°í•  ë§Œí¼ í”„ë ˆì„ ë“œëì´ ë°œìƒí•˜ê³  Destroyê°€ ìŒ“ì—¬, GC.Collect()ê°€ í•„ìš”í•˜ê²Œ ë  ê²½ìš° ì£¼ê¸°ì ì¸ í”„ë ˆì„ ë“œëì˜ ì›ì¸ì´ ë˜ëŠ” ê²ƒì„ Profilerë¥¼ í†µí•´ í™•ì¸í•˜ì˜€ìŠµë‹ˆë‹¤. ë¨¼ì €, Instantiateì˜ ê²½ìš° í”Œë ˆì´ì–´ì˜ í™”ë©´ì„ Fade-in ë°©ì‹ìœ¼ë¡œ ê²€ì€í™”ë©´ìœ¼ë¡œ ë°”ê¾¼ í›„, í•´ë‹¹ ì‹œê°„ë™ì•ˆ ì†Œí™˜í•˜ë„ë¡ í•˜ì—¬ í•´ë‹¹ ë¶€ë¶„ì„ ìˆ¨ê²¼ìœ¼ë©° ê°€ë¹„ì§€ ì»¬ë ‰í„°ì˜ ì‘ë™ì˜ ê²½ìš° ì˜¤ë¸Œì íŠ¸ í’€ë§ì„ í†µí•´ ìµœì†Œí™” ì‹œí‚¤ëŠ” ë°©ì•ˆì„ ì„ íƒí•˜ì˜€ìŠµë‹ˆë‹¤.

##### A - 2. ì•„í‚¤í…ì²˜ì˜ 2ê°œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

- PoolDataSO.cs

  ì–´ë–¤ ì˜¤ë¸Œì íŠ¸ë¥¼ ëª‡ ê°œ ë¯¸ë¦¬ ë¡œë“œí•˜ë©° ìµœëŒ€ ëª‡ê°œ ìƒì„±í• ì§€ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.

  ì´ë¥¼ í†µí•´ ì½”ë“œ ìˆ˜ì • ì—†ì´ ìœ ë‹ˆí‹° ì—ë””í„° ë‚´ì—ì„œ ê´€ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/ScriptableObjects/PoolDataSO.cs

[CreateAssetMenu(fileName = "PoolData", menuName = "ScriptableObjects/PoolData")]
public class PoolDataSO : ScriptableObject
{
    [System.Serializable]
    public struct PoolItem
    {
        [Tooltip("A unique key to identify this prefab.")]
        public string key;

        [Tooltip("The actual prefab to be pooled.")]
        public GameObject prefab;

        [Tooltip("The amount of objects to preload.")]
        public int preloadAmount;

        [Tooltip("The maximum amount of objects to pool.")]
        public int maxAmount;
    }

    [Header("Prefabs to pool settings")]
    [Tooltip("List of (key, prefab) pairs.")]
    public List<PoolItem> _poolItems;
}

```
<br/>

- PoolManager.cs

  PoolDataSOë¥¼ ì½ì–´ì™€ í•„ìš”í•œ ì˜¤ë¸Œì íŠ¸ë“¤ì„ ë¯¸ë¦¬ ìƒì„±í•˜ì—¬ ë¹„í™œì„±í™” ìƒíƒœë¡œ ë³´ê´€í•©ë‹ˆë‹¤.

  ê²Œì„ ì¤‘ ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì˜¤ë¸Œì íŠ¸ë¥¼ ìš”ì²­í•˜ë©´ ë¹„í™œì„±í™”ëœ ì˜¤ë¸Œì íŠ¸ ì¤‘ì— ì°¾ì•„ í™œì„±í™” í•˜ê±°ë‚˜ ê°œìˆ˜ê°€ ë¶€ì¡±í•˜ë©´ í•´ë‹¹ Poolê³¼ ì—°ë™ì‹œì¼œ ìƒˆë¡œ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤. ì‚¬ìš©ì´ ëë‚œ ì˜¤ë¸Œì íŠ¸ëŠ” ë‹¤ì‹œ í’€ì— ë°˜ë‚©ë©ë‹ˆë‹¤.

```cpp
// In Scripts/Managers/PoolManager.cs
public class PoolManager : Singleton<PoolManager>
{
		private Dictionary<string, List<GameObject>> _pools;
		// ...
		// ê²Œì„ ì‹œì‘ ì‹œ í’€ì„ ì´ˆê¸°í™”í•˜ê³  ì˜¤ë¸Œì íŠ¸ë¥¼ ë¯¸ë¦¬ ìƒì„±
		private void InitializePools() { /* ... */ }
		
		// í’€ì—ì„œ ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë©”ì„œë“œ
		public GameObject GetFromPool(string key)
		{
		    // ...
		    // ë¹„í™œì„±í™”ëœ ì˜¤ë¸Œì íŠ¸ë¥¼ ì°¾ê¸°
		    foreach (GameObject item in poolList)
		    {
		        if (!item.activeSelf)
		        {
		            item.SetActive(true);
		            return item; // ì°¾ì•˜ìœ¼ë©´ í™œì„±í™”í•´ì„œ ë°˜í™˜
		        }
		    }
		
		    // ë¹„í™œì„±í™”ëœ ì˜¤ë¸Œì íŠ¸ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„± (ìµœëŒ€ ê°œìˆ˜ ì œí•œ í™•ì¸)
		    GameObject newObj = Instantiate(prefab);
		    // ...
		    return newObj;
		}
		
		// ì‚¬ìš©ì´ ëë‚œ ì˜¤ë¸Œì íŠ¸ë¥¼ í’€ì— ë°˜ë‚©í•˜ëŠ” ë©”ì„œë“œ
		public void ReturnToPool(GameObject obj, string key)
		{
		    // ...
		    obj.SetActive(false); // ì˜¤ë¸Œì íŠ¸ë¥¼ íŒŒê´´í•˜ëŠ” ëŒ€ì‹  ë¹„í™œì„±í™”ë§Œ í•¨
		}
}
```
<br/><br/>

#### B. 'íˆíŠ¸ë°•ìŠ¤ LOD' ì‹œìŠ¤í…œ ì„¤ê³„ë¥¼ í†µí•œ ë¬¼ë¦¬ ì—°ì‚° ìµœì í™” ì‹œë„

##### B - 1. ì´ˆê¸° ì„¤ê³„

ìˆ˜ì‹­ ë§ˆë¦¬ì˜ ëª¬ìŠ¤í„°ê°€ ë™ì‹œì— í™”ë©´ì— ë“±ì¥í•˜ëŠ” ìƒí™©ì—ì„œ ì—¬ëŸ¬ ê°œì˜ ë³µí•© ì½œë¼ì´ë”ê°€ í° ë¶€í•˜ë¥¼ ì¤„ ê²ƒì´ë¼ê³  ê°€ì„¤ì„ ì„¸ì› ìŠµë‹ˆë‹¤. ë˜í•œ í”Œë ˆì´ì–´ì™€ ë©€ë¦¬ ë–¨ì–´ì ¸ ìˆì–´ ì •ë°€í•œ íƒ€ê²© íŒì •ì´ í•„ìš” ì—†ëŠ” ëª¬ìŠ¤í„°ê¹Œì§€ ë³µì¡í•œ ë¬¼ë¦¬ ì—°ì‚°ì„ í•˜ëŠ” ê²ƒì´ ìì› ë‚­ë¹„ë¼ê³  íŒë‹¨í•˜ì˜€ìŠµë‹ˆë‹¤.

##### B - 2. ì½œë¼ì´ë” ë™ì  í™œì„±í™” êµ¬í˜„

í”Œë ˆì´ì–´ì™€ ê±°ë¦¬ì— ë”°ë¼ ì •í•´ì§„ ê±°ë¦¬ë³´ë‹¤ ë©€ì–´ì§€ë©´ ë³µí•© ì½œë¼ì´ë”ë¥¼ ëª¨ë‘ ë¹„í™œì„±í™”í•˜ê³ , ëª¸ì„ ë‘˜ëŸ¬ì‹¼ ë‹¨ìˆœí•œ ì½œë¼ì´ë”ë¥¼ í™œì„±í™”í•˜ê²Œ ë©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/Monster/Refactoring/Core/MonsterControllerRefactored.cs
private void UpdateHitBoxQuality()
        {
            if (_target == null || _isDead) return;

            float distanceToTarget = Vector3.Distance(transform.position, _target.position);

            if (!_isHighDetail && distanceToTarget < _highDetailHitBoxDistance)
            {
                StartCoroutine(SwitchToHighDetail());
            }

            else if (_isHighDetail && distanceToTarget > _lowDetailHitBoxDistance)
            {
                StartCoroutine(SwitchToLowDetail());
            }
        }

        private IEnumerator SwitchToHighDetail()
        {
            SetHighDetailHitboxes(true); // High Detail ì½œë¼ì´ë” ê·¸ë£¹ í™œì„±í™”
            _isHighDetail = true;
            yield return null;
            if (_lowDetailHitBox != null) _lowDetailHitBox.SetActive(false);
        }
        
        private IEnumerator SwitchToLowDetail()
        {
            if (_lowDetailHitBox != null) _lowDetailHitBox.SetActive(true);
            _isHighDetail = false;
            yield return null;
            SetHighDetailHitboxes(false); // High Detail ì½œë¼ì´ë” ê·¸ë£¹ ë¹„í™œì„±í™”
        }
        
        void SetHighDetailHitboxes(bool isActive)
        {
            foreach (Collider collider in _highDetailHitBoxes)
            {
                if (collider != null)
                {
                    collider.enabled = isActive;
                }
            }
        }
```

#### B - 3. í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ê³„ ë° í”„ë¡œíŒŒì¼ëŸ¬ í™œìš©

ì‹¤ì œ ì–¼ë§ˆë‚˜ CPU ë¹„ìš©ì„ ì‚¬ìš©í•˜ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•´, í•´ë‹¹ ì‚¬í•­ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ì‚¬í•­ë“¤ì€ ë³€ìˆ˜ë¥¼ ìµœëŒ€í•œ í†µì œí•˜ê³  ì˜¤ì§, ë™ì ìœ¼ë¡œ ì›€ì§ì´ë©° ê·¼ê±°ë¦¬ ~ ì›ê±°ë¦¬ì—ì„œ ì›€ì§ì´ëŠ” ë‹¨ìˆœì½œë¼ì´ë”ë¡œ êµ¬ì„±ëœ 30ê°œ ì½œë¼ì´ë”ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ì™€ 300ê°œ ì½œë¼ì´ë”ë¡œ êµ¬ì„±ëœ ì˜¤ë¸Œì íŠ¸ 10ê°œë¥¼ ë‘ê³ , ì´ì•Œì„ ë°œì‚¬í•˜ëŠ” ê²ƒê³¼ ë˜‘ê°™ì´ í•œ í›„ ì¶©ëŒê¹Œì§€ ì‹œì¼°ì§€ë§Œ ì‹¤ì œë¡œ í˜„ì¬ ê²Œì„ì—ì„œëŠ” ìì› í• ë‹¹ ì°¨ì´ê°€ ì‚¬ì‹¤ìƒ ì—†ë‹¤ëŠ” ê²ƒì„ í™•ì¸í•˜ì˜€ìŠµë‹ˆë‹¤. ë˜í•œ ì˜¤íˆë ¤, ì¶©ëŒ ê²€ì‚¬ë¥¼ ìœ„í•œ Phaseì—ì„œ íŠ¸ë¦¬ ë‚´ì— ë“±ë¡ë˜ëŠ” ì‚¬í•­ì´ ë³€ê²½ë¨ìœ¼ë¡œ ì¸í•´ ìì›ì´ ì¶”ê°€ í• ë‹¹ë˜ëŠ” ìƒí™©ì´ ë  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ì´ë¡œ ì¸í•´ ì„£ë¶€ë¥¸ ì‹œë„ë³´ë‹¤ëŠ” ë°˜ë“œì‹œ ì œí•œëœ í™˜ê²½ì„ êµ¬ì„±í•œ í›„ ê°€ì„¤ì„ ê²€ì¦í•˜ê³ ë‚˜ì„œ ë¶„ì„ì„ í†µí•´ ê°œë°œí•´ì•¼í•œë‹¤ëŠ” ê²ƒì„ ë‹¤ì‹œ í•œ ë²ˆ ì§šê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

<br/>

---

### 4. ê²Œì„ ê´€ë¦¬ ì‹œìŠ¤í…œ: ìƒíƒœ ê´€ë¦¬ì™€ ë°ì´í„° ê¸°ë°˜ ë ˆë²¨ ë””ìì¸

#### A. GameManagerë¥¼ í†µí•œ ê²Œì„ ìƒíƒœ ê´€ë¦¬

##### A - 1. ì´ˆê¸° ì„¤ê³„

ê²Œì„ì˜ ìƒíƒœì— ë”°ë¼ í™œì„±í™”ë˜ì–´ì•¼ í•  ë¡œì§ì´ ëª¨ë‘ ë‹¤ë¥¸ë°, ê° ì‹œìŠ¤í…œì´ ë…ë¦½ì ìœ¼ë¡œ ê²Œì„ ìƒíƒœë¥¼ íŒë‹¨í•˜ê³  ë™ì‘í•œë‹¤ë©´ ë³µì¡ì„±ì´ ì¦ê°€í•˜ê³ , ìƒíƒœ ì „í™˜ ì‹œ ë™ê¸°í™” ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ê²Œì„ì˜ í˜„ì¬ ìƒíƒœë¥¼ ìœ ì¼í•˜ê²Œ ê´€ë¦¬í•˜ê³ , ìƒíƒœ ë³€ê²½ì„ ëª¨ë“  ì‹œìŠ¤í…œì— ì „íŒŒí•˜ëŠ” ê´€ë¦¬ìê°€ í•„ìš”í•˜ë‹¤ê³  ìƒê°í•˜ì˜€ìŠµë‹ˆë‹¤.

##### A - 2. ì•„í‚¤í…ì²˜ì˜ 3ê°œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

- GameState Enum

  ê²Œì„ì´ ê°€ì§ˆ ìˆ˜ ìˆëŠ” ìƒíƒœë“¤ì„ enumìœ¼ë¡œ ì •ì˜í•˜ì—¬ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/Managers/GameManager.cs
public enum GameState
{
		Initialize, // ê²Œì„ ì´ˆê¸°í™” ì¤‘
		MainMenu,   // ë©”ì¸ ë©”ë‰´ í™”ë©´
		InGame,     // ì¼ë°˜ í”Œë ˆì´ ì¤‘
		Boss,       // ë³´ìŠ¤ì „ ì§„í–‰ ì¤‘
		Victory,    // ê²Œì„ í´ë¦¬ì–´
		Pause,      // ì¼ì‹œ ì •ì§€
		GameOver    // ê²Œì„ ì˜¤ë²„
}
```
<br/>

- ChangeGameState & OnGameStateChanged Event

  ê²Œì„ ìƒíƒœë¥¼ ë³€ê²½í•˜ëŠ” ë©”ì„œë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤.

  ì´ë¥¼ í†µí•´ ê²Œì„ ë‚´ ë‹¤ë¥¸ ëª¨ë“  ì‹œìŠ¤í…œì—ê²Œ ê²Œì„ ìƒíƒœ ë³€í™”ë¥¼ ì•Œë¦½ë‹ˆë‹¤.

```csharp
// In Scripts/Managers/GameManager.cs
public class GameManager : Singleton<GameManager>
{
		private GameState _currentState;
		public event System.Action<GameState> OnGameStateChanged; // ìƒíƒœ ë³€ê²½ì„ ì•Œë¦¬ëŠ” ì´ë²¤íŠ¸ ì±„ë„
		public GameState GetGameState() => _currentState; // í˜„ì¬ ìƒíƒœë¥¼ ì•ˆì „í•˜ê²Œ ì¡°íšŒí•˜ëŠ” ë©”ì„œë“œ
		
		public void ChangeGameState(GameState newState)
		{
		    if (_currentState == newState) return; // ê°™ì€ ìƒíƒœë¡œì˜ ë³€ê²½ì€ ë¬´ì‹œ
		
		    _currentState = newState;
		    // ?.Invoke : êµ¬ë…ìê°€ ìˆì„ ë•Œë§Œ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œ NullReferenceException ë°©ì§€
		    OnGameStateChanged?.Invoke(newState); // ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ë¥¼ êµ¬ë…ìë“¤ì—ê²Œ ì „íŒŒ
		}
		// ...
}
```
<br/>

- BGMController (ì´ë²¤íŠ¸ êµ¬ë…ì êµ¬í˜„ ì˜ˆì‹œ)

  ì´ë²¤íŠ¸ êµ¬ë…ì ì˜ˆì‹œë¡œ, GameManagerì˜ OnGameStateChanged ì´ë²¤íŠ¸ë¥¼ êµ¬ë…í•©ë‹ˆë‹¤.

  ì´ë²¤íŠ¸ê°€ Invokeë˜ë©´, ìë™ìœ¼ë¡œ ë“±ë¡ëœ ë©”ì„œë“œê°€ í˜¸ì¶œë˜ì–´ ìƒˆë¡œìš´ ê²Œì„ ìƒíƒœì— ë§ëŠ” BGMì„ ì¬ìƒí•˜ëŠ” ë“±ì˜ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```csharp
// In Scripts/SSW/AudioController/BGMController.cs
public class BGMController : Singleton<BGMController>
{
		// ... (EventReferences for BGM)
		protected override void Awake()
		{
		    base.Awake();
		    // GameManagerì˜ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë… ì‹ ì²­
		    // += ì—°ì‚°ìë¥¼ í†µí•´ OnGameStateChanged ë©”ì„œë“œë¥¼ ì´ë²¤íŠ¸ 'ëŒ€ë¦¬ì(delegate)'ì— ë“±ë¡
		    GameManager.Instance.OnGameStateChanged += OnGameStateChanged;
		}
		
		// ê²Œì„ ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ GameManagerì— ì˜í•´ ìë™ìœ¼ë¡œ í˜¸ì¶œë  ë©”ì„œë“œ
		private void OnGameStateChanged(GameManager.GameState newState)
		{
		    StopCurrentBGM(); // ì¼ë‹¨ ê¸°ì¡´ BGM ì •ì§€
		    switch (newState) // ìƒˆë¡œìš´ ìƒíƒœì— ë§ëŠ” BGM ì¬ìƒ
		    {
		        case GameManager.GameState.MainMenu:
		            PlayMenuBGM();
		            break;
		        case GameManager.GameState.InGame:
		            PlayMainBGM();
		            break;
		        case GameManager.GameState.Boss:
		            PlayBossBGM();
		            break;
		        // ... (Victory ìƒíƒœ ë“± ì¶”ê°€ ê°€ëŠ¥)
		    }
		}
		// ... (Play BGM methods)
}
```
<br/><br/>
#### B. ScriptableObjectë¥¼ í™œìš©í•œ ë°ì´í„° ê¸°ë°˜ ëª¬ìŠ¤í„° ì›¨ì´ë¸Œ ì‹œìŠ¤í…œ

##### B - 1. ì´ˆê¸° ì„¤ê³„

ì´ˆê¸°ì—ëŠ” ê³ ì •ëœ ìœ„ì¹˜ì—ì„œ ëª¬ìŠ¤í„° ìƒì„±ì„ í•˜ì˜€ì§€ë§Œ, ê¸°ë³¸ì ì¸ ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ê³  ë‚˜ì„œ, ê¸°íší•œ ë°¸ëŸ°ì‹±ì— ë§ê²Œ ëª¬ìŠ¤í„°ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë„ë¡ ScriptableObjectë¥¼ í™œìš©í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ì ì„ í™œìš©í•˜ì—¬ ìœ„ì¹˜, ëª¬ìŠ¤í„° ìˆ˜, í¬íƒˆ ì¢…ë¥˜ì™€ ê°™ì´ ì—¬ëŸ¬ ìƒí™©ì— ëŒ€ì‘í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

##### B - 2. ì•„í‚¤í…ì²˜ì˜ 2ê°œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ

- SpawnerWaveSO.cs

  ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œ ëª¬ìŠ¤í„° ì›¨ì´ë¸Œë¥¼ ì‹œê°ì ìœ¼ë¡œ ì„¤ê³„í•  ìˆ˜ ìˆë„ë¡ ë°ì´í„° êµ¬ì¡°ë¥¼ ì •ì˜í•˜ì˜€ìŠµë‹ˆë‹¤.

  ê° í˜ì´ì¦ˆë¡œ êµ¬ì„±í•˜ì—¬, ì§€ì† ì‹œê°„ê³¼ ëª¬ìŠ¤í„° ìŠ¤í¬ë„ˆ ì •ë³´ë¥¼ ê°€ì§€ë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

```csharp
// In Scripts/ScriptableObjects/SpawnerWaveSO.cs
[CreateAssetMenu(fileName = "SpawnerWaveSO", menuName = "ScriptableObjects/SpawnerWaveSO", order = 1)]
public class SpawnerWaveSO : ScriptableObject
{
    // Phase List
    [System.Serializable]
    public class Phase // ê° ì›¨ì´ë¸Œ ë‹¨ê³„ë¥¼ ì •ì˜
    {
        public string phaseName;
        public float duration; // ì´ í˜ì´ì¦ˆì˜ ì§€ì† ì‹œê°„
        public List<SpawnerActivation> activations; // List of spawner activations in this phase
    }

    [System.Serializable]
    public class SpawnerActivation
    {
        public string monsterKey;         // The type of monster to activate
        public int spawnersToActivate;    // How many of this type of spawner to activate randomly
    }

    public List<Phase> phases; // List of phases in the wave
}

```
<br/>

- WaveManager.cs

  SpawnerWaveSO ì—ì…‹ì„ í• ë‹¹ ë°›ì€ í›„, í˜ì´ì¦ˆë“¤ì„ ìˆœì„œëŒ€ë¡œ ì§„í–‰í•˜ê²Œ ë©ë‹ˆë‹¤.

  í•´ë‹¹ í˜ì´ì¦ˆì— ì •ì˜ëœ ì¢…ë¥˜ì™€ ìˆ˜ë§Œí¼ì˜ ëª¬ìŠ¤í„° ìŠ¤í¬ë„ˆë¥¼ ë§µ ìƒì—ì„œ ëœë¤í•˜ê²Œ í™œì„±í™”ì‹œí‚µë‹ˆë‹¤.

```csharp
// In Scripts/Managers/WaveManager.cs
public class WaveManager : MonoBehaviour
{
    [System.Serializable]
    public class SpawnerGroup
    {
        public string monsterKey;
        public List<Spawner> spawners;
    }

    [Header("Wave Data")]
    [SerializeField] private SpawnerWaveSO waveData;

    [Header("Spawner Groups")]
    [SerializeField] private List<SpawnerGroup> spawnerGroups;

    private Dictionary<string, List<Spawner>> _spawnersByType = new Dictionary<string, List<Spawner>>();
    private List<Spawner> _activeSpawners = new List<Spawner>();
    // Start is called before the first frame update
    void Start()
    {
        InitializeSpawnerDictionary(); // ë”•ì…”ë„ˆë¦¬ êµ¬ì¶•
        DeactivateAllRegisteredSpawners(); // ê²Œì„ ì‹œì‘ ì‹œ ëª¨ë“  ìŠ¤í¬ë„ˆ ë¹„í™œì„±í™”
        StartCoroutine(CoRunWaveTimeline()); // ì›¨ì´ë¸Œ ì‹œë‚˜ë¦¬ì˜¤ ì½”ë£¨í‹´
    }

    private void InitializeSpawnerDictionary()
    {
        foreach (var group in spawnerGroups)
        {
            _spawnersByType[group.monsterKey] = group.spawners;
        }
    }

    private void DeactivateAllRegisteredSpawners()
    {
        foreach (var group in spawnerGroups)
        {
            foreach (var spawner in group.spawners)
            {
                if(spawner != null)
                {
                    spawner.gameObject.SetActive(false);
                }
            }
        }
    }

    private IEnumerator CoRunWaveTimeline()
    {
        foreach (var phase in waveData.phases) // í˜ì´ì¦ˆ ì‹¤í–‰
        {
            // Last Phase Cleanup
            foreach (var spawner in _activeSpawners)
            {
                if (spawner != null)
                {
                    spawner.gameObject.SetActive(false);
                }
            }
            _activeSpawners.Clear();

            // Activate spawners for the current phase
            foreach (var activation in phase.activations)
            {
                ActivateSpawners(activation.monsterKey, activation.spawnersToActivate);
            }

            // Wait for the duration of the phase
            yield return new WaitForSeconds(phase.duration);
        }
    }
		
		// íŠ¹ì • ì¢…ë¥˜ì˜ ìŠ¤í¬ë„ˆë¥¼ countê°œ ë§Œí¼ ëœë¤í•˜ê²Œ í™œì„±í™”í•˜ëŠ” ë©”ì„œë“œ
    private void ActivateSpawners(string monsterKey, int count)
    {
        List<Spawner> availableSpawners = _spawnersByType[monsterKey];
        
        List<Spawner> spawnersToActivate = availableSpawners.OrderBy(x => Random.value).Take(count).ToList();
        
        foreach(var spawner in spawnersToActivate)
        {
            spawner.gameObject.SetActive(true);
            _activeSpawners.Add(spawner);
        }
    }
}
```

#### C. ê²°ê³¼

- ë‘ ì‹œìŠ¤í…œ ëª¨ë‘ ìµœì¢…ì ìœ¼ë¡œ ê²Œì„ì´ ì™„ì„±ëœ ë‹¨ê³„ì—ì„œëŠ” ì•ˆì •ì„±ì„ ë†’ì—¬ì£¼ê³  ê¼­ í•„ìš”í•œ ê¸°ëŠ¥ì´ë¼ê³  ìƒê°ë˜ì§€ë§Œ, ì¤‘ê°„ì— ê¸°ëŠ¥ ë³„ í…ŒìŠ¤íŠ¸ë¥¼ ì§„í–‰í•  ë•ŒëŠ” ì˜¤íˆë ¤ ì˜ì¡´ì„±ì´ ìƒê²¨ ë³„ë„ì˜ í…ŒìŠ¤íŠ¸ í™˜ê²½ì„ ë§Œë“¤ë©° ì§„í–‰í•˜ëŠ” ë¬¸ì œì ì´ ìˆì—ˆìŠµë‹ˆë‹¤.

<br/><br/>

## 5. ì‚¬ìš© ì—ì…‹

**Unlimited Music Bundle: Vol. 1**,<br/>     **Universal Audio Bundle**,<br/>     **Stylized Shoot & Hit Vol.1**,<br/>     **Stylized Shoot & Hit Vol.2**,<br/>     **UNI VFX: Ulimate pack for Visual Effect Graph**,<br/>     **Hybrid Action Music Pack Vol.3**,<br/>     **Universal Sound FX**,<br/>     **Ultimate Clean GUI Pack**,<br/>      **Epic Toon FX**,<br/>     **Sci-Fi Battle Weapons**,<br/>     **All Sky Free - 10 Sky / SkyBox Set**,<br/>     **Droll Robots Pack1**,<br/>     **Factory Interior + Warehouse Props Vo1 - Bundle**,<br/>     **UNI VFX: Realistic Explosions, Fire & Smoke for Visual Effect Graph**
<br/><br/><br/>

## 6. ì°¸ê³  ìë£Œ

Unity Documentation

ê¸€ë¡œë²ŒICTí¬í„¸ | VR/AR/MR ì‹œì¥ë™í–¥ ë³´ê³ ì„œ 2024 | â€œ[https://www.globalict.kr/product/product_view.do?menuCode=040200&artclCode=DP0200&catNo=325&p_cateNo=&viewMode=view&knwldNo=144041â€](https://www.globalict.kr/product/product_view.do?menuCode=040200&artclCode=DP0200&catNo=325&p_cateNo=&viewMode=view&knwldNo=144041%E2%80%9D)

GGIT | [ê¸°ìˆ ] ëŒì•„ì˜¨ VR ê²Œì„, ëŒ€ì¤‘í™” ì‹œëŒ€ ì—´ë¦¬ë‚˜ | â€œ[https://www.kocca.kr/global/2023_7+8/sub02_04.htmlâ€](https://www.kocca.kr/global/2023_7+8/sub02_04.html%E2%80%9D)

Steam | Steam í•˜ë“œì›¨ì–´ ë° ì†Œí”„íŠ¸ì›¨ì–´ ì„¤ë¬¸ì¡°ì‚¬: February 2025 | â€œ[https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam?l=koreanaâ€](https://store.steampowered.com/hwsurvey/Steam-Hardware-Software-Survey-Welcome-to-Steam?l=koreana%E2%80%9D)

ìœ ë‹ˆí‹° TIPS í•µì‹¬ë§Œ ì™ì™! Baked Lighting ì´í•´í•˜ê¸° | "https://www.youtube.com/watch?v=J4iVXAYaJfQ&t=91s"

ìœ ë‹ˆí‹° TIPS ìƒˆë¡œì›Œì§„ ê¸¸ì°¾ê¸° AI Navigation 2.0 ê³µëµ | "https://www.youtube.com/watch?v=A0nsAjsJqHg&t=40s"

Knockback NavMeshAgents using Physics | "https://www.youtube.com/watch?v=0NH5obeOb7I"

2ì›” ì•Œì“¸ìœ ì¡ : ë©”ëª¨ë¦¬ ìµœì í™”ë¥¼ ìœ„í•œ ì—ì…‹ ê´€ë¦¬ | "https://www.youtube.com/watch?v=52ehLUfk3DQ&t=3328s"

Visual Design Methods for Virtual Reality, Mike Alger

VR ì»¨í…ì¸  ì œì‘ ì‹œ ì£¼ì˜í•´ì•¼ í•˜ëŠ” ì‚¬í•­ë“¤ | "https://www.youtube.com/watch?v=rxC4FasB46M"

The Art of Game Design - Jesse Schell

<br/><br/>

## 7. í”„ë¡œì íŠ¸ ë¦¬ë·°

- **ì˜ì¡´ì„± ìµœì†Œí™”ë¥¼ í†µí•œ ì‹œìŠ¤í…œ í†µì œ**

ê²Œì„ ì—”ì§„ì—ì„œ ì œê³µí•˜ëŠ” NavMesh Agent, Rigidbody, Root Motion Animation ë“± ì˜¤ë¸Œì íŠ¸ì˜ ë¬¼ë¦¬ì  ë™ì‘ì— ì§ì ‘ì ìœ¼ë¡œ ì˜í–¥ì„ ì£¼ëŠ” ì‹œìŠ¤í…œì€ ê°€ëŠ¥í•œ ìµœì†Œí™”í•´ì•¼ í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì„œë¡œ ë‹¤ë¥¸ ì‹œìŠ¤í…œ ê°„ ì¶©ëŒì´ë‚˜ ì˜ˆê¸°ì¹˜ ëª»í•œ ë¶€ì‘ìš©ì„ ì¤„ì´ê³ , ê°œë°œ ë° ë””ë²„ê¹… íš¨ìœ¨ì„ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

- **í”Œë ˆì´ì–´ ìŠ¤í‚¬ ì¶”ê°€**

í˜„ì¬ í”Œë ˆì´ ë°©í–¥ì„±ì´ ìŠˆíŒ…ì— ì¹˜ìš°ì³ ìˆì–´, ì´ˆê¸° ê¸°íšì— ë§ëŠ” ë±€ì„œë¼ì´í¬ ìŠ¤íƒ€ì¼ë¡œ ë³€ê²½í•˜ê¸° ìœ„í•´ ê¸°ì¡´ ì‹œìŠ¤í…œì„ í™œìš©í•œ ìŠ¤í‚¬ ì¶”ê°€ ë° ê°œì„ ì´ í•„ìš”í•©ë‹ˆë‹¤.

- **ë³´ìŠ¤ ìŠ¤í‚¬ ë° í˜ì´ì¦ˆ ì¶”ê°€**

ë³´ìŠ¤ ì‹œìŠ¤í…œì€ êµ¬ì¶•ë˜ì–´ ìˆìœ¼ë‚˜ íŒ¨í„´ì´ ë‹¨ì¡°ë¡­ê³  í˜ì´ì¦ˆê°€ ë¶€ì¡±í•˜ì—¬, í”Œë ˆì´ì–´ê°€ ìœ„í˜‘ê°ì„ ëŠë¼ê¸° ì–´ë ¤ìš°ë¯€ë¡œ, í˜ì´ì¦ˆë³„ ìŠ¤í‚¬ê³¼ íŒ¨í„´ ì¶”ê°€ê°€ í•„ìš”í•©ë‹ˆë‹¤.

- **ì´ë²¤íŠ¸ ë“œë¦¬ë¸ êµ¬ì¡°ì˜ ì—ë””í„° ì‹œê°í™”**

í˜„ì¬ ì´ë²¤íŠ¸ êµ¬ì¡°ë¥¼ ScriptableObject ê¸°ë°˜ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì—ë””í„° ìƒì—ì„œ ì´ë²¤íŠ¸ í˜¸ì¶œ ì—¬ë¶€ë¥¼ ëª…ì‹œì ìœ¼ë¡œ í™•ì¸ì´ ê°€ëŠ¥í•˜ë„ë¡ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

- **ì• ë‹ˆë©”ì´ì…˜ íŒŒë¼ë¯¸í„° í•´ì‹œí™” ì ìš©**

Animator íŒŒë¼ë¯¸í„°ë¥¼ ë¬¸ìì—´ì´ ì•„ë‹Œ í•´ì‹œ ê°’ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì˜¤íƒ€ ë° ì´ë¦„ ë³€ê²½ì— ë”°ë¥¸ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê³  ì„±ëŠ¥ì„ ê°œì„ í•´ì•¼ í•©ë‹ˆë‹¤.

- **SO ë°ì´í„° êµ¬ë¶„ ë° êµ¬ê¸€ ì‹œíŠ¸ ì—°ë™**

í˜„ì¬ í…ŒìŠ¤íŠ¸ìš©ê³¼ í”Œë ˆì´ìš© ë°ì´í„°ê°€ êµ¬ë¶„ë˜ì–´ ìˆì§€ ì•Šê³ , ì™¸ë¶€ì—ì„œ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ëŠ” ì²´ê³„ê°€ ë¯¸ë¹„í•˜ë¯€ë¡œ í…ŒìŠ¤íŠ¸ìš© / í”Œë ˆì´ìš© SOë¥¼ ëª…í™•íˆ êµ¬ë¶„í•˜ê³ , êµ¬ê¸€ ì‹œíŠ¸ ì—°ë™ì„ í†µí•´ ì™¸ë¶€ì—ì„œ ë°ì´í„° í¸ì§‘ í›„ SOë¡œ ìë™ ë°˜ì˜ë˜ë„ë¡ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

- **ì‹œê° íš¨ê³¼ ì¶”ê°€**

Fracturing & Destruction, Bullet Decal ë“±ê³¼ ê°™ì€ ê²Œì„ í”Œë ˆì´ ê²½í—˜ì— ì§ì ‘ì ìœ¼ë¡œ ì˜í–¥ì„ ì£¼ëŠ” ì´í™íŠ¸ ì¶”ê°€ê°€ í•„ìš”í•©ë‹ˆë‹¤.

íšŒê³ : Standalone VR ë²„ì „ìœ¼ë¡œ ë¹Œë“œê¹Œì§€ ì§„í–‰í•˜ë©°, ë‹¨ìˆœ ê¸°ëŠ¥ ê°œë°œì„ ë„˜ì–´ í•œì •ëœ ìì›ìœ¼ë¡œ ê²Œì„ì„ ê°œë°œí•˜ê¸° ìœ„í•œ ìµœì í™” ë°©ì‹ì— ëŒ€í•´ ë§ì´ ì•Œ ìˆ˜ ìˆëŠ” ê¸°íšŒê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì•ìœ¼ë¡œ ì»´í“¨í„° ê·¸ë˜í”½ìŠ¤, ë©”ëª¨ë¦¬ ê´€ë¦¬, í”„ë¡œê·¸ë˜ë° ì–¸ì–´ì™€ ê²Œì„ ì‹œìŠ¤í…œ ì„¤ê³„ì— ëŒ€í•´ ë” ê¹Šì´ í•™ìŠµí•  í•„ìš”ê°€ ìˆë‹¤ê³  ëŠê¼ˆìŠµë‹ˆë‹¤.

ë˜í•œ ëª¬ìŠ¤í„° êµ¬í˜„ ë‹¹ì‹œ ê³µê²© ì „ ê°ë„ ë³´ì •ì„ ìœ„í•œ íšŒì „ ë¬¸ì œë¥¼ í•´ê²°ì„ ìœ„í•´ ì‹œê°„ì„ ë§ì´ íˆ¬ìí•˜ì˜€ì§€ë§Œ, ë¶ˆí•„ìš”í•œ ì˜ˆë¹„ ë™ì‘ì´ ì—†ì´ ì •í™•í•˜ê²Œ í”Œë ˆì´ì–´ë¥¼ ê³µê²©í•˜ëŠ” ê²ƒì— ëŒ€í•´ í•´ê²°í•˜ì§€ ëª»í•œ ì ì´ ìˆì—ˆìŠµë‹ˆë‹¤. ì´ì— ëŒ€í•´, ì°¨ì„¸ëŒ€ ì• ë‹ˆë©”ì´ì…˜ ì•„í‚¤í…ì²˜ì™€ ë°©ëŒ€í•œ ë°ì´í„° ê·¸ë¦¬ê³ , ê¹Šì´ ìˆëŠ” í”„ë¡œê·¸ë˜ë° ëŠ¥ë ¥ì— ëŒ€í•œ í•„ìš”ì„±ì„ ëŠë¼ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë¡œ ì¸í•´, ì´ˆê¸° ê¸°íš ì˜ë„ì—ì„œ ë²—ì–´ë‚˜ì§€ ì•Šê³  ëª°ì…ë„ ìˆëŠ” ê²Œì„ì„ ì œì‘í•˜ê¸° ìœ„í•´ì„œëŠ” ë‹¨ìˆœíˆ ê¸°ëŠ¥ êµ¬í˜„ ìˆ˜ì¤€ì´ ì•„ë‹Œ ì—”ì§„ ê¸°ìˆ  ìì²´ë¥¼ ì´í•´í•˜ê³  ì ìš©í•  ìˆ˜ ìˆëŠ” ì—­ëŸ‰ì„ ìŒ“ì•„ì•¼ í•œë‹¤ëŠ” í™•ì‹ ì„ ì–»ê²Œ ë˜ëŠ” ê³„ê¸°ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.
